
\subsection{Abstract Semantics}\label{subsec:abstract-semantics}
This section will describe the abstract semantics of SQAAL.

\autoref{eq:generalBOP} through \ref{eq:generalUOP}, show the definition of abstract operations on members of $\mathsf{Val} \; A$.
These operations are denoted by $\aop$, where $\aop$ is defined in \autoref{eq:operation}.
These equations provide a systematic way to perform abstract operations on values within the lattice $\mathsf{Val} \ A$.
The specific binary $\aaop$ are defined for the respective types later on, allowing for flexibility and customization based on the domain and requirements of the analysis.

\begin{align}
    \aop &: \mathsf{Val} \; A \rightarrow \mathsf{Val} \; B \rightarrow \mathsf{Val} \; C \label{eq:operation} \\
    \mathsf{Single} \; s_1 \aop \mathsf{Single} \; s_2 &= \mathsf{Single} \; (s_1 \aaop s_2) \label{eq:generalBOP} \\
    \mathsf{Single} \; s \aop \mathsf{List} \; S &= \mathsf{List} \; \{ s \aaop s' \mid s' \in S \} \\
    \mathsf{List} \; S \aop \mathsf{Single} \; s &= \mathsf{List} \; \{ s' \aaop s \mid s' \in S \}  \\
    \mathsf{List} \; S_1 \aop \mathsf{List} \; S_2 &= \mathsf{List} \; \{ s_1 \aaop s_2 \mid s_1 \in S_1, s_2 \in S_2 \} \\
    \aop (\mathsf{Single} \; s) &= \mathsf{Single} \; (\aaop s) \\
    \aop (\mathsf{List} \; S) &= \mathsf{List} \; \{ \aaop s \mid s \in S \} \label{eq:generalUOP}
\end{align}

Similarly we define $\app{op}$, which is for operations of sets.
\begin{align}
    \app{op} &: \mathsf{Val} \; A \rightarrow \mathsf{Val} \; B \rightarrow \mathsf{Val} \; C \\
    \mathsf{Single} \; s_1 \app{op} \mathsf{Single} \; s_2 &= \mathsf{List} \; (\{s_1\} \op \{s_2\}) \\
    \mathsf{Single} \; s \app{op} \mathsf{List} \; S &= \mathsf{List} \; (\{ s \} \op S) \\
    \mathsf{List} \; S \app{op} \mathsf{Single} \; s &= \mathsf{List} \; (S \op \{ s \})  \\
    \mathsf{List} \; S_1 \app{op} \mathsf{List} \; S_2 &= \mathsf{List} \; (S_1 \op S_2) \\
    \app{op} (\mathsf{Single} \; s) &= \mathsf{List} \; (\op \{ s \}) \\
    \app{op} (\mathsf{List} \; S) &= \mathsf{List} \; (\op S )
\end{align}
This will also be helpful later, when we define the abstract semantics of SQL commands.

\subsubsection{Abstract Semantics of Boolean expressions}
We define the general abstract semantics of Boolean expressions such that $\aab{bop}$ is a specialized instance of $\aaop$ in the following manner:
\begin{align}
    \begin{split}
        \aab{bop} : \mathcal{P}(\{\true, \false, null\}) &\rightarrow \mathcal{P}(\{\true, \false, null\}) \\
        &\rightarrow \mathcal{P}(\{\true, \false, null\})
    \end{split}
\end{align}
\begin{align}
    B_1 \;\aab{bop}\; B_2 &= \bigcup_{b_1 \in B_2, b_2 \in B_2} b_1 \;\aaab{bop}\; b_2
\end{align}
Where $\aaab{bop}$ is defined for $\land$, $\lor$ and $\neg$ in \autoref{tab:aaabland}, \autoref{tab:aaablor} and \autoref{tab:aaabneg} respectively.

\autoref{eq:abstract-bool-semantics-start} through \ref{eq:abstract-bool-semantics-end} show the abstract semantics of Boolean expressions $(\absboolsem{})$ defined in \autoref{eq:bool-operation}, that is logical operators and comparisons between expressions.
$\ab{\mathfrak{E}}$ describes the set of abstract states. $\absexpsem{exp}$ describes the abstract evaluation of an expression, $(\rho_{\ab{d}}, \rho_{\ab{a}})$ is an abstract state in the database.
In \autoref{eq:abstract-bool-semantics-end}, we check if either of the two expressions are lists; if that is the case and they are the same type, we add $\{\{\texttt{false}\}\}$ to the result, as we are unsure if the two expressions are equal.
Otherwise, we proceed as usual.

\begin{align}
    \absboolsem{\cdot} &: \mathbb{B} \rightarrow \ab{\mathfrak{E}} \rightarrow \mathsf{Val} \; \mathcal{P}(\{\true, \false, null\}) \label{eq:bool-operation}
\end{align}
\begin{align}
    \absboolsem{\texttt{true}}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \mathsf{Single} \; \{\true\} \label{eq:abstract-bool-semantics-start} \\
    \absboolsem{\texttt{false}}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \mathsf{Single} \; \{\false\} \\
    \absboolsem{b_1 \lor b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absboolsem{b_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ab{\lor} \absboolsem{b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \absboolsem{b_1 \land b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absboolsem{b_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ab{\land} \absboolsem{b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \absboolsem{\neg b}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{\neg} \absboolsem{b}(\rho_{\ab{d}}, \rho_{\ab{a}})  \\
    % \absboolsem{e_1 \neq e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{\neg}(\absexpsem{e_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \;\ab{=}\; \absexpsem{e_2}(\rho_{\ab{d}}, \rho_{\ab{a}})) \label{eq:abstract-bool-semantics-end1} \\
    \absboolsem{e_1 \;comp\; e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &=  \begin{cases}
        \app{\{\{\texttt{false,true}\}\} \cup} E \quad \quad \text{if } w\\
        E_1 \;\ab{\comp}\; E_2 \quad \quad \quad \quad \text{otherwise}
    \end{cases} \nonumber \\
    \begin{split}
        \text{where } w&=(E_1 = \mathsf{List} \; S_1 \lor E_2 = \mathsf{List} \; S_2) \nonumber\\
        &\land E_1 \;\ab{\comp}\; E_2 = E \nonumber
    \end{split} \\
    \text{and } E_1 &= \absexpsem{e_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \nonumber \\
    \text{and }  E_2 &= \absexpsem{e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \label{eq:abstract-bool-semantics-end}
    %\absboolsem{e_1 \;comp\; e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= E_1 \;\ab{\comp}\; E_2 \quad \text{where }  E_1 = \absexpsem{e_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ \text{and } E_2 = \absexpsem{e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \label{eq:abstract-bool-semantics-end}
\end{align}

\begin{table}[H]
    \centering
    \caption{test}
    \begin{tabular}{c|ccc}
        $\aaab{\land}$ & $\true$ & $\false$ & $\mnull$ \\
        \hline
        $\true$ & $\{\true\}$ & $\{\false\}$ & $\{\mnull\}$ \\
        $\false$ & $\{\false\}$ & $\{\false\}$ & $\{\false\}$ \\
        $\mnull$ & $\{\mnull\}$ & $\{\false\}$ & $\{\mnull\}$ \\
    \end{tabular}
    \label{tab:aaabland}
\end{table}

\begin{table}[H]
    \centering
    \caption{test}
    \begin{tabular}{c|ccc}
        $\aaab{\lor}$ & $\true$ & $\false$ & $\mnull$ \\
        \hline
        $\true$ & $\{\true\}$ & $\{\true\}$ & $\{\true\}$ \\
        $\false$ & $\{\true\}$ & $\{\false\}$ & $\{\mnull\}$ \\
        $\mnull$ & $\{\true\}$ & $\{\mnull\}$ & $\{\mnull\}$ \\
    \end{tabular}
    \label{tab:aaablor}
\end{table}

\begin{table}[H]
    \centering
    \caption{test}
    \begin{tabular}{c|ccc}
        $\aaab{\neg}$ & $\true$ & $\false$ & $\mnull$ \\
        \hline
        $\true$ & $\{\false\}$ & $\{\true\}$ & $\{\mnull\}$ \\
    \end{tabular}
    \label{tab:aaabneg}
\end{table}

\subsubsection{Comparison of Abstract Integers and Strings}\label{subsubsec:abstract-comparison}
For abstract integers (union of intervals) $\mathscr{I}_1$ and $\mathscr{I}_2$ and arbitrary values $X_1$ and $X_2$ (either intervals or regular expressions), we define their abstract comparison in \autoref{eq:aaabcomp}s through \ref{eq:aaabcomp3}.
For abstract equality (\autoref{eq:aaabcomp}), we require that the two abstract values being compared be of the same type: abstract integers or abstract strings, lest the result be undefined.
If the two abstract values only represent the same value, equality can only be true.
If the values the two abstract values represent do not intersect, equality can only be false.
Otherwise, they overlap; in this case, we are unsure whether the concrete values that can be derived are equal.

\begin{align} \nonumber
    X_1 \;\aab{=}\; X_2 &= \begin{cases}
        \begin{cases}
        \{\true\} & \text{if } a\\
        \{\false\} & \text{if } X_1 \cap X_2 = \emptyset \\
        \{\true, \false\} & \text{otherwise }
        \end{cases} & \text{if $b$} \\
        \text{undefined} & \text{otherwise}
    \end{cases}\\
    \text{where } a&=|X_1| = |X_2| = 1 \land X_1 = X_2 \nonumber\\
    \text{and } b&=X_1 \text{ and } X_2 \text{ is of the same type}
    \label{eq:aaabcomp}
\end{align}

$min(\mathscr{I})$ and $max(\mathscr{I})$ denotes the maximum and minimum value represented by $\mathscr{I}$, we argue that such values can easily be computed if $\mathscr{I}$ is kept in a canonical form within the actual implementation.
With the former mentioned, \autoref{eq:aaabcomp2} and \ref{eq:aaabcomp3} should be self-explanatory.
To clarify, we only allow abstract integers to be compared this way.

\begin{align}\label{eq:aaabcomp2}
    \mathscr{I}_1 \;\aab{<}\; \mathscr{I}_2 &= \begin{cases}
        \{\true\} & \text{if } \max(\mathscr{I}_1) < \min(\mathscr{I}_2) \\
        \{\false\} & \text{if } \max(\mathscr{I}_2) \leq \min (\mathscr{I}_1) \\
        \{\true, \false\} & \text{otherwise}
    \end{cases}
\end{align}
\begin{align}\label{eq:aaabcomp3}
    \mathscr{I}_1 \;\aab{\leq}\; \mathscr{I}_2 &= \begin{cases}
        \{\true\} & \text{if } \max(\mathscr{I}_1) \leq \min(\mathscr{I}_2) \\
        \{\false\} & \text{if } \max(\mathscr{I}_2) < \min (\mathscr{I}_1) \\
        \{\true, \false\} & \text{otherwise}
    \end{cases}
\end{align}

\subsubsection{Abstract Semantics of Expressions}

Here we define the abstract semantics of expressions in SQAAL.

\autoref{sem:exp1} and ~\ref{sem:exp2} describe the semantics of constants.
In \autoref{sem:exp3} and ~\ref{sem:exp4} we describe the semantics of variables.
In the case of database variables in \autoref{sem:exp4}, we assume attribute names do not clash.
\autoref{eq:unary-op} and ~\ref{eq:binary-op} describe the semantics of unary and binary operations on expressions.
The justification of abstract binary operations is analogous to the one given for the semantics of comparison operators (\autoref{eq:abstract-bool-semantics-end}).
\begin{align}
    \absexpsem{\cdot} : \mathbb{E} \rightarrow \ab{\mathfrak{E}} \rightarrow \mathsf{Val} \; \mathbf{REG} \cup \mathsf{Val} \; \mathbf{INT}
\end{align}
\begin{align}
    \absexpsem{n}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \mathsf{Single} \; \{ [n, n] \} \label{sem:exp1} \\
    \absexpsem{k}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \mathsf{Single} \; R,  \text{ such that }\mathcal{L}(R) = \{ k \} \label{sem:exp2} \\
    \absexpsem{v_a}(\rho_{\ab{d}}, \rho_{\ab{a}}) &=  \rho_{\ab{a}}(v_a) \label{sem:exp3} \\
    \begin{split}
        \absexpsem{v_t}(\rho_{\ab{d}}, \rho_{\ab{a}}) &=  \mathsf{List} \; \pi_{v_t}(\rho_d(v_d)) \\
        &\text{ such that } v_t \in attr(v_d) \label{sem:exp4}
    \end{split} \\
    \absexpsem{op_u \; e}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{op_u} \; (\absexpsem{e}(\rho_{\ab{d}}, \rho_{\ab{a}})) \label{eq:unary-op} \\
    \absexpsem{e_1 \;op_b\; e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absexpsem{e_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \;\ab{op_b}\; \absexpsem{e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \label{eq:binary-op}
\end{align}
Before defining the abstract operations, $\aaop$, for expressions, we will define some auxiliary functions.
We define the length of a regular expression $R$, $\|R\|$ as:
\begin{align}\label{eq:r1}
    \|R\| & = \{ \left[ \|\min(R)\|, +\infty \right) \} \\
    \text{where } & \|\min(R)\| = \min\{ \|s\| \mid s \in R \} \\ \label{eq:r2}
    \text{and } & \|s\| \text{ is the length of the word $s$}
\end{align}
The former is obviously an over-approximation, the length of the shortest $\|\min(R)\|$ can be found by classical shortest path algorithm on the automata of $R$, $\mathcal{A}(R)$.
Such algorithms have a time complexity $\Theta(E + V \log V)$, where $E$ is the number of edges in the automata and $V$ is the number of states.
We deem this acceptable.
If $R$ does not contain a term $R'^\star$, we are essentially forced to find the longest path, this can be shown to be NP-hard, therefore we always approximate the length to be unbounded in the positive direction.

Next, we define $cvt$, which is abstact string conversion over regular expressions, defined by recursing on the operands of union, intersection, concatenation and Kleene star.
In the base case, a single symbol is converted as defined by $op$.
In the case of the complement, seen in \autoref{eq:complement}, we convert $\overline{R}$ to its DFA equivalent by the usual construction, $\mathcal{A}:REG\rightarrow DFA$~\cite{sipserbook}.
This automaton is then converted back to a regular expression by the usual GNFA construction, $\mathcal{R}: DFA\rightarrow REG$~\cite{sipserbook}, thus eliminating the complement.
\begin{align}
    cvt(op, R_1 \cup R_2) &= cvt(op, R_1) \cup cvt(op, R_2) \\
    cvt(op, R_1 \cap R_2) &= cvt(op, R_1) \cap cvt(op, R_2) \\
    cvt(op, R_1R_2) &= cvt(op, R_1) \; cvt(op, R_2) \\
    cvt(op, R^\star) &= (cvt(op, R))^\star \\
    cvt(op, \overline{R}) &= cvt(op, (\mathcal{R} \circ \mathcal{A}) (\overline{R})) \label{eq:complement} \\
    cvt(op, \sigma) &= op(\sigma)
\end{align}

\autoref{eq:concat} to \ref{eq:length} describes a subset of String operators, present in PostgreSQL, abstractly.
\begin{align}\label{eq:concat}
    &R_1 \;\aab{||}\; R_2 = R_1R_2 \\
    \begin{split}
        &\aab{lower}(R) = cvt(\sigma \mapsto \sigma', R) \\
        & \quad \quad \text{such } \text{that } \sigma' \text{ is the lowercase representation of } \sigma
    \end{split}\\
    \begin{split}
        & \aab{upper}(R) = cvt(\sigma \mapsto \sigma', R) \\
        & \quad \quad \text{such } \text{that $\sigma'$ is the uppercase representation of $\sigma$}
    \end{split}\\
    \begin{split}
        &\aab{bit\_length}(R) = \|cvt(\sigma \mapsto \sigma', R)\| \\
        & \quad \quad \text{such } \text{that $\sigma'$ is the bit string of $\sigma$}
    \end{split} \\ \label{eq:length}
    &\aab{length}(R) = \|R\|
\end{align}

\autoref{eq:abstractBOP} describes how to do binary operations on numbers.
The arithmetic operations, $\aaab{aop}$, are defined as follows for intervals.
\begin{align}\label{eq:abstractBOP}
    \bigcup \mathcal{I} \;\aab{aop}\; \bigcup \mathcal{I}' &= \bigcup_{\mathscr{I}\in \mathcal{I}, \mathscr{I}'\in \mathcal{I}'}\mathscr{I}\aaab{aop}\mathscr{I}'\nonumber\\
    \text{where } \mathcal{I}&=\{\mathscr{I}_1,\dots,\mathscr{I}_n\}\nonumber\\
    \text{and } \mathcal{I}'&=\{\mathscr{I}'_1,\dots,\mathscr{I}'_n\}
\end{align}

\subsubsection{Abstract Semantics of Predicates}
The base rule of all the predicates is defined in \autoref{eq:atomicformulas}, as this is the base case for all the other predicates.
It takes atomic formulas, $a_f$, and returns the abstract truth value of $a_f$.
The other predicates all build on this base case with rules such as negation, disjunction and conjunction.
\begin{align}
    \abspredsem{\cdot} &: \mathbb{W} \rightarrow \ab{\mathfrak{E}} \rightarrow \mathsf{Val} \; \{\true, \false, \mnull\} \\ \label{eq:atomicformulas}
    \abspredsem{a_f}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absboolsem{a_f}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \abspredsem{\neg \phi}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{\neg} \left( \abspredsem{\phi}(\rho_{\ab{d}}, \rho_{\ab{a}}) \right) \\
    \abspredsem{\phi_1 \lor \phi_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \abspredsem{\phi_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ab{\lor} \abspredsem{\phi_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \abspredsem{\phi_1 \land \phi_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \abspredsem{\phi_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ab{\land} \abspredsem{\phi_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \abspredsem{\exists v_n \; \phi}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \underset{s \in \absexpsem{x}}{\ab{\bigvee}} \abspredsem{\phi[s/v_n]}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \abspredsem{\forall v_n \; \phi}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \underset{s \in \absexpsem{x}}{\ab{\bigwedge}} \abspredsem{\phi[s/v_n]}(\rho_{\ab{d}}, \rho_{\ab{a}})
\end{align}

\subsubsection{Abstract Semantics of SQL statements}

First we define $var_{\ab{t}}(\phi)$ to be the vector of database variables in table $\ab{t}$ appearing in $\phi$, ordered by the way they appear in the schema of $\ab{t}$.
Next we define $\abstable \downarrow_{\true}^{(\rho_{\ab{d}}, \rho_{\ab{a}})} \phi, \abstable \downarrow_{\false}^{(\rho_{\ab{d}}, \rho_{\ab{a}})} \phi$ and  $\abstable \downarrow_{\unknown}^{(\rho_{\ab{d}}, \rho_{\ab{a}})} \phi$ to be the set of tuples in $\ab{t}$ where $\phi$ is definitely true, definitely false and where we are unsure respectively, formally:
\begin{align}
    \begin{split}
        \abstable \downarrow_{\true}^{(\rho_{\ab{d}}, \rho_{\ab{a}})} \phi &= \{ l \in \ab{t} \mid \mathsf{Single} \; \{ \true \} = \abspredsem{\phi[\pi_{\mathbf{v}_t}(l)/\mathbf{v}_t]}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
        &\text{ for } \mathbf{v}_t = var_{\ab{t}}(\phi) \}
    \end{split}\\
    \begin{split}
        \abstable \downarrow_{\false}^{(\rho_{\ab{d}}, \rho_{\ab{a}})} \phi &= \{ l \in \ab{t} \mid \mathsf{Single} \; \{ \false \} = \abspredsem{\phi[\pi_{\mathbf{v}_t}(l)/\mathbf{v}_t]}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
        &\text{ for } \mathbf{v}_t = var_{\ab{t}}(\phi) \}
    \end{split}\\
    \begin{split}
        \abstable \downarrow_{\unknown}^{(\rho_{\ab{d}}, \rho_{\ab{a}})} \phi &= \{ l \in \ab{t} \mid \true \in b \land b \in \abspredsem{\phi[\pi_{\mathbf{v}_t}(l)/\mathbf{v}_t]}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
        &\text{ for } \mathbf{v}_t = var_{\ab{t}}(\phi) \} \setminus \abstable \downarrow_{\true}^{(\rho_{\ab{d}}, \rho_{\ab{a}})} \phi
    \end{split}
\end{align}

The domain and codomain of the analysis functions for SQL statements is as follows:

\begin{equation}
    \abssqlsem{\cdot} : \mathbb{C}_{sql} \rightarrow \ab{\mathfrak{E}} \rightarrow \ab{\mathfrak{E}}
\end{equation}

Each of the analysis functions for SQL statements requires some explanation.
Therefore, we will present each of them carefully in the sequel.

The abstract \textit{select}, takes all values in the table where we are definitely sure or maybe sure that the predicate evaluates to true for the current state.
Then it wraps them in a $\mathsf{List}$ 'label' and inserts this in the lattice of the respective variable before assigning the variable to this value.
\begin{align}
\begin{split} \nonumber
\abssqlsem{\langle select&(v_a, v_d, \mathbf{v}_t), \phi \rangle}(\rho_{\ab{d}}, \rho_{\ab{a}})
= \biggl(\rho_{\ab{d}}, \rho_{\ab{a}}[v_a \mapsto \\
    &\mathsf{List} \Bigl( \pi_{\mathbf{v}_t} \bigl(\abstable \downarrow_{\true}^{(\env{\ab{d}}, \env{\absvars})} \phi \cup \abstable \downarrow_{\unknown}^{(\env{\ab{d}}, \env{\absvars})} \phi \bigr) \Bigr) \into \lookupcl(v_a) ]\biggr)
\end{split}\\
    &\text{where } \ab{t}=\rho_{\ab{d}}(v_d)
\end{align}

For \textit{insert}, we evaluate each expression in $\mathbf{e}$, and take the product of them as the set of abstract tuples to be inserted.
We take the product as each expression might evaluate to a $\mathsf{list}$ type.
These respective values are inserted into the lattice of the column they correspond to.
At last, we turn the values into actual abstract tuples in the table, here we find it helpful to view a tuple as a function $attr(\ab{t}) \rightarrow \lookupcl(v_1) \cup \lookupcl(v_2) \cup \dots \cup \lookupcl(v_n)$ where $attr(\ab{t}) = \{v_1, v_2, \dots, v_n\}$.
In particular, we start with a tuple with all entries equal to null $\lambda\_.\mnull$, then for each of the evaluations of the expressions we update the tuples to take those values in the correct places.
\begin{align}
    \abssqlsem{\langle insert(v_d, \mathbf{v}_t, &\mathbf{e}), \phi \rangle}(\rho_{\ab{d}}, \rho_{\ab{a}}) = (\rho_{\ab{d}}[v_d\mapsto \ab{t}\cup s], \rho_{\ab{a}}) \nonumber \\
    \text{where } \mathsf{List} \; S &= \app{\bigtimes_{i = 0}^{n}} \absexpsem{e_i}(\rho_{\ab{d}}, \rho_{\ab{a}}) \into \lookupcl(v_i) \nonumber\\
    \text{and } s &= \left\{ (\lambda\_.\mnull)[\mathbf{v}_t \mapsto \mathbf{s}] \;\middle|\; \mathbf{s} \in S\right\} \nonumber\\
    \text{and } \ab{t}&=\rho_{\ab{d}}(v_d)
\end{align}

In the case of an \textit{update} command, we evaluate the expressions as for \textit{insert}.
In the case of the abstract tuples that definitely satisfy the predicate, we update them, and in the case we are unsure, we update them to the join of its current value and the incoming value.
\begin{align}
    \abssqlsem{\langle upd&ate(v_d, \mathbf{v}_t, \mathbf{e}), \abspred \rangle} (\env{\ab{d}}, \env{\absvars}) = (\env{\ab{d}}[v_d\mapsto \ab{t'}], \env{\absvars})\nonumber\\
    &\text{where } \ab{t}=\rho_{\ab{d}}(v_d) \nonumber\\
    &\text{and }\abstable' = \ab{t} \downarrow_{\false}^{(\env{\ab{d}}, \env{\absvars})} \phi \nonumber\\
    \begin{split}
         &\cup \biggl\{ l\Bigl[ \mathbf{v}_t \mapsto \pi_{\mathbf{v}_t}(s) \sqcup \pi_{\mathbf{v}_t}(l) \Bigr] \;\Big|\;\\
         &l \in \ab{t} \downarrow_{\unknown}^{(\env{\ab{d}}, \env{\absvars})} \phi \land s \in \app{\bigtimes_{i = 0}^{n}} \absexpsem{e_i}(\rho_{\ab{d}}, \rho_{\ab{a}}) \into \lookupcl(v_i)\biggr\} \nonumber
    \end{split} \\
    \begin{split}
        &\cup \biggl\{ l\Bigl[ \mathbf{v}_t \mapsto \pi_{\mathbf{v}_t}(s) \Bigr] \;\Big|\;\\
        &l \in \ab{t} \downarrow_{\true}^{(\env{\ab{d}}, \env{\absvars})} \phi \land s \in \app{\bigtimes_{i = 0}^{n}} \absexpsem{e_i}(\rho_{\ab{d}}, \rho_{\ab{a}}) \into \lookupcl(v_i)\biggr\}
    \end{split}
\end{align}

In the case of \textit{delete}, we remove all tuples where we are definitely sure that they should be removed.
\begin{align}
    \abssqlsem{\langle delete&(v_d, \mathbf{v}_t), \abspred \rangle} (\env{\ab{d}}, \env{\absvars}) = (\env{\ab{d}}[v_d\mapsto \ab{t'}], \env{\absvars}) \nonumber\\
    &\text{where } \ab{t}=\rho_{\ab{d}}(v_d) \nonumber\\
    &\text{and }\abstable' = \abstable \downarrow_{\unknown}^{(\env{\ab{d}}, \env{\absvars})} \phi \cup \abstable \downarrow_{\false}^{(\env{\ab{d}}, \env{\absvars})} \phi
\end{align}

\subsubsection{Abstract Semantics of Instructions}
This section will cover the abstract semantics of Instructions in SQAAL.
In general, the abstract semantics of instructions are defined as a function that takes a set of abstract environments and returns an updated set of abstract environments.
This means that when an instruction is made, the abstract environment is updated to reflect the changes made by the instruction.
An example of this could be with the skip instruction, where the abstract environment is not changed.


Let $\ab{P}$ be a set of abstract environments $(\env{\ab{d}}, \env{\absvars})$.

\begin{align}
    \abssem{\cdot} &: \mathbb{I} \rightarrow \mathcal{P}(\ab{\mathfrak{E}}) \rightarrow \mathcal{P}(\ab{\mathfrak{E}}) \\
    \abssem{\texttt{skip}}(\ab{P}) &= \ab{P} \\
    \begin{split}
        \abssem{v_a := e}(\ab{P}) &= \{(\env{\ab{d}}, \env{\absvars}[v_a \mapsto s']) \mid (\env{\ab{d}}, \env{\absvars}) \in \ab{P} \\
        &\land s = \absexpsem{e}(\env{\ab{d}}, \env{\absvars}) \land s' = s \into \lookupcl(v_a) \}
    \end{split}\\
    \abssem{v_a := \; ?}(\ab{P}) &= \{(\env{\ab{d}}, \env{\absvars}[v_a \mapsto \mathsf{Single} \; \top]) \mid (\env{\ab{d}}, \env{\absvars}) \in \ab{P} \} \\
    \abssem{b}(\ab{P}) &= \{ (\env{\ab{d}}, \env{\absvars}) \in \ab{P} \mid \true \in B \land B \in \absboolsem{b}(\env{\ab{d}}, \env{\absvars}) \} \\
    \abssem{C_{sql}}(\ab{P}) &= \{\abssqlsem{C_{sql}}(\env{\ab{d}}, \env{\absvars}) \mid (\env{\ab{d}}, \env{\absvars}) \in \ab{P} \}
\end{align}

As a last note on the abstract semantics, we know $(\mathcal{P}(\ab{\mathfrak{E}}), \subseteq, \cup, \cap)$ is a finite and complete lattice.
Therefore, if $\abssem{I}$ is monotone, our analysis will be decidable.
Hence, we prove the following theorem:
\begin{restatable}{theorem}{csql}\label{thm:csql}
    $\abssem{I}$ is a monotone function in a finite and complete lattice.
\end{restatable}

% \begin{align*}
%     E^\# \llbracket R_1 \texttt{||} R_2 \rrbracket                          \\
%     = E^\# \llbracket R_1 \rrbracket \oplus  E^\# \llbracket R_2 \rrbracket \\
%     \text{where } R_1 \text{ and } R_2 \text{ are regular expressions and } \\
%     \oplus \text{ is the concatenation operator.}
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{bit\_length} (R) \rrbracket \\
%     =  [length(B(s)), length(B(S))]                     \\
%     bit\_length \text{ returns a range of the binary}   \\
%     \text{ representation of regular expression } R.    \\
%     \text{where } B(s) \text{ is the binary representation of }s
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{char\_length} (R) \rrbracket       \\
%     =  [length(s), lenght(S)]                                  \\
%     char\_length \text{ returns a range of the shortest and}   \\
%     \text{ longest string created from the regular expression} \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{lower} (c) \rrbracket =c'                                                    \\
%     E^\# \llbracket \texttt{lower}(R_1 \cup R_2) \rrbracket                                              \\
%     = E^\# \llbracket \texttt{lower}(R_1) \rrbracket \cup E^\# \llbracket \texttt{lower}(R_2) \rrbracket \\
%     E^\# \llbracket \texttt{lower}(R_1 \cap R_2) \rrbracket                                              \\
%     = E^\# \llbracket \texttt{lower}(R_1) \rrbracket \cap E^\# \llbracket \texttt{lower}(R_2) \rrbracket \\
%     E^\# \llbracket \texttt{lower}(R_1^*) \rrbracket                                                     \\
%     = E^\# \llbracket \texttt{lower}(R_1)^* \rrbracket                                                   \\
%     \text{Where }c \in \Sigma \text{ and } c' \text{ is the lower case of } c.                           \\
%     R_1 \text{ and } R_2 \text{ are regular expressions.}                                                \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{upper}(R) \rrbracket \\
%     \text{Where upper is the same as lower but converts to upper case.}
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{position}(R_1, in, R_2) \rrbracket \\
%     = I                                             \\
%     \text{where } R1 \text{ and } R2 \text{ are regular expressions and }
%     I \text{ is an integer.}                        \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{sub\_string} (R, I_1, I_2) \rrbracket \\
%     = []                                                          \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{trim} ('pos', R_1 \text{ from } R_2) \rrbracket                            \\
%     =  \texttt{trim}('pos', R_1 \text{ from } R_2)                                                     \\
%     \texttt{trim} \text{ removes all leading, trailing or both occurrences of } R_2 \text{ from } R_1. \\
%     \text{where } R_1 \text{ and } E_2 \text{ are regular expressions, and 'pos' is a string.}         \\
% \end{align*}
%
% \todo[inline]{Casper says:
%     For the tree definitions above a definition should be give for position, substring and trim.
%     We should be able to implement the abstract semantics by following the semantics above.
% }
%
% \subsection{Abstract Interpretation of belongs}
% To provide a precise definition of the belongs function, envision a lattice composed of partitions of a language. We aim to identify the most precise partition that encompasses a given expression. In essence, we seek to pinpoint which element in the lattice accurately describes the expression's location. Simply stating that it resides somewhere within the entire set would lack practicality.
%
% Partitions within this lattice may overlap, symbolizing intersections of languages. The lattice itself is complete, with the top element representing the entire set of languages, and the bottom element indicating the empty set.
%
% Navigating this lattice involves starting from the top and descending until we reach a point where no partitions cover the expression. At this juncture, we have identified the most precise set of partitions that encompass the expression.
%
% $ belongs(x)=\bigsqcap\{x' \mid x \sqsubseteq x', x' \in X\} $
% Taking an expression $x$, we seek to identify the most precise partition that encompasses it. We do this by finding the greatest lowerbound of all partitions that contain $x$.
% % todo same as above
%
% % \begin{restatable}{lemma}{updatemonotone}
% %     $\abssem{C_{update}^\#}$ is monotone.
% % \end{restatable}
% % \pfsketch{
% %     For $\abstable \sqsubseteq \abstablep$ if $\abssem{C_{update}^\#}$ updates elements in $\abstable$ the same elements must be updated in $\abstablep$, therefore the order is determined by the remaining unchanged elements and therefore order is preserved.
% %     If an element not in $\abstable$ is update is changed in $\abstablep$ order is still preserved as the element is 'swapped' for another.
% % }
