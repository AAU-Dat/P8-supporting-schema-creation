\subsection{Overview for function definitions} \label{subsec:function-definitions}

\todo[inline]{Lars says: Write the tables in from the paper:Abstract interpretation of database query languages}
\begin{center}
    \begin{tabular}{l l}
        $n: \mathbb{Z}$                          & Integer                                                   \\
        $k: \S$                                  & String                                                    \\
        $c: \mathbb{C}$                          & Constants                                                 \\
        $v_a: \mathbb{V}_a$                      & Application variables                                     \\
        $v_d: \mathbb{V}_d$                      & Database variables (attributes) involved in SQL commands  \\
        $v: \mathbb{V} \triangleq \mathbb{V}_d $ & Variables                                                 \\
        $e: \mathbb{E}$                          & Arithmetic expressions                                    \\
        $b: \mathbb{B}$                          & Boolean expressions                                       \\
        $A_{sql}: \mathbb{A}_{sql}$              & Action part of SQL commands                               \\
        $\tau: \mathbb{T}$                       & Terms                                                     \\
        $a_f: \mathbb{A}_f$                      & Atomic formulas                                           \\
        $\phi : \mathbb{W}$                      & Well-formed formulas (pre-condition part of SQL commands) \\
        $C_{sql}: \mathbb{C}_{sql}$              & SQL commands                                              \\
        $I: \mathbb{I}$                          & Instructions/commands                                     \\
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{l l}
        $c ::=$ & $n \mid k$ \\
        $e ::=$ & $c \mid v_d \mid v_a \mid ap_u e \mid e_1 op_b e_2$ , where $op_u$ and $op_b$ represent unary and binary arithmetic operations respectively. \\
        $e ::=$ & $e_1 = e_2 \mid e_1 \geq \mid e_1 \leq e_2 \mid e_1 > e_2 \mid e_1 < e_2 \mid e_1 \neq e_2 \mid \neg b \mid b_1 \lor b_2 \mid b_1 \land b_2 \mid \texttt{true} \mid \texttt{flase}$ \\
        $\tau ::=$ & $c \mid v_a \mid v_d \mid f_n(\tau_1, \tau_2, \dots, \tau_n)$, where $f_n$ is an $n$-any function. \\
        $a_f ::=$ & $R_n(\tau_1, \tau_2, \dots, \tau_n) \mid \tau_1 = \tau2$, where $R_n$ is an $n$-ary relation: $R_n(\tau_1, \tau_2, \dots, \tau_n) \in \{ \texttt{true}, \texttt{false}\}$ \\
        $\phi ::=$ & $a_f \mid \neg \phi_1 \mid \phi_1 \lor \phi_2 \mid \phi_1 \land \phi_2 \mid \forall \textbf{x}_i \phi \mid \exists \textbf{x}_i \phi$ \\
        $g(\overrightarrow{e}) ::=$  & $\texttt{GROUP BY} \overrightarrow{e} \mid id$ \\
        $r ::= $ & $\texttt{DISTINCT} \mid \texttt{ALL}$ \\
        $s ::= $ & $\texttt{AVG} \mid \texttt{SUM} \mid \texttt{MAX} \mid \texttt{MIN} \mid \texttt{COUNT}$ \\
        $h(e) ::= $ & $s \bigcirc r(e) \mid \texttt{DISTINCT}(e) \mid id$ \\
        $h(*) ::= $ & $\texttt{COUNT(*)}$ \\
        $\overrightarrow{h}(\overrightarrow{\textbf{x}}) ::= $ & $\langle h_1(\textbf{x}_1), \dots, h_n(\textbf{x}_n)\rangle$, where $\overrightarrow{h} = \langle \rangle$ \\
        $f(\overrightarrow{e}) ::=$ & $\texttt{ORDER BY ACE}(\overrightarrow{e}) \mid \texttt{ORDER BY DESC}(\overrightarrow{e}) \mid id$ \\
        $A_{sql} :: =$ & $select(v_a, f(\overrightarrow{e'}), r(\overrightarrow{h}(\overrightarrow{\textbf{x}})), \phi, g(\overrightarrow{e})) \mid update(\overrightarrow{v_d}, \overrightarrow{e}) \mid delete(\overrightarrow{v_d})$ \\
        $C_{sql} ::=$ & $\langle A_{sql}, \phi \rangle \mid C_{sql}' \texttt{UNION} C_{sql}'' \mid C_{sql}' \texttt{INTERSECT} C_{sql}'' \mid C_{sql}' \texttt{MINUS} C_{sql}''$ \\
        $I ::=$ & $skip \mid v_a := e \mid v_a := ? \mid C_{sql} \mid$ if $b$ then $I_1$ else $I_2$ $\mid$ while $b$ do $I$ $\mid$ $I_1; I_2$ \\
    \end{tabular}
\end{center}


\subsection{Abstract Semantics}\label{subsec:abstract-semantics}
\todo[inline]{Lars says: We should add a glossary for SQAAL}
This section will describe to abstract semantics of SQAAL.
In genereal, this paper represents strings as a list of characters. 


\begin{align}\label{eq:generalBOP}
    S_1 \aop S_2 &= \{ s_1 \aaop s_2 \mid s_1 \in S_1, s_2 \in S_2 \} \\ \label{eq:generalUOP}
\begin{align}\label{eq:generalBOP}
    S_1 \aop S_2 &= \{ s_1 \aaop s_2 \mid s_1 \in S_1, s_2 \in S_2 \} \\ \label{eq:generalUOP}
    \aop S &= \{\aaop s \mid s \in S \}
\end{align}
In \autoref{eq:generalBOP} and \autoref{eq:generalUOP} we see the how the general binary and unary operation works in SQAAL.
We denote binary operations on sets with $\widehat{op}$, and $\aab{op}$ for binary operations on elements in those sets.


In \autoref{eq:generalBOP} and \autoref{eq:generalUOP} we see the how the general binary and unary operation works in SQAAL.
We denote binary operations on sets with $\widehat{op}$, and $\aab{op}$ for binary operations on elements in those sets.



\subsubsection{Abstract Semantics of Boolean expressions}
As described in~\autoref{subsec:abstract-semantics}, we will now define the general abstract semantics of boolean expressions.
$\aab{bop}$ and $\aaab{bop}$ are used to represent boolean operations on sets and elements respectively.

\begin{align}
    B_1 \;\aab{bop}\; B_2 = \bigcup_{b_1 \in B_2, b_2 \in B_2} b_1 \;\aaab{bop}\; b_2
\end{align}

\autoref{eq:abstract-bool-semantics} shows the abstract semantics of boolean expressions, such as logical operators, comparisons, and negations.
In general it works by evaluating a boolean value and its domain. for true and false values it returns a set of sets that contain either true or false. This is done due to the way that the abstract semantics is defined.
This logic is then applied to each of the different boolean expressions, where binary boolean expression evaluate the left and right side of the expression and then apply the operator to the result, and for unary expressions it applies the operator to the result of the expression.
For the comparison operators it evaluates the left and right side of the expression as expressions (integers or other forms of expressions) and then applies the operator to the result, returning a boolean value.

\begin{align}\label{eq:abstract-bool-semantics}
    \absboolsem{\texttt{true}}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \{\{\true\}\} \\
    \absboolsem{\texttt{false}}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \{\{\false\}\} \\
    \absboolsem{b_1 \lor b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absboolsem{b_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ab{\lor} \absboolsem{b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \absboolsem{b_1 \land b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absboolsem{b_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ab{\land} \absboolsem{b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \absboolsem{\neg b}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{\neg} \absboolsem{b}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \absboolsem{e_1 \neq e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{\neg}(\absexpsem{e_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \;\ab{=}\; \absexpsem{e_2}(\rho_{\ab{d}}, \rho_{\ab{a}})) \\
    \absboolsem{e_1 \;comp\; e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absexpsem{e_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \;\ab{\comp}\; \absexpsem{e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
\end{align}

\begin{table}[H]
    \centering
    \begin{tabular}{c|ccc}
        $\aaab{\lor}$ & $\true$ & $\false$ & $\mnull$ \\
        \hline
        $\true$ & $\{\true\}$ & $\{\false\}$ & $\{\mnull\}$ \\
        $\false$ & $\{\false\}$ & $\{\false\}$ & $\{\false\}$ \\
        $\mnull$ & $\{\mnull\}$ & $\{\false\}$ & $\{\mnull\}$ \\
    \end{tabular}
    \label{tab:aaablor}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{c|ccc}
        $\aaab{\land}$ & $\true$ & $\false$ & $\mnull$ \\
        \hline
        $\true$ & $\{\true\}$ & $\{\true\}$ & $\{\true\}$ \\
        $\false$ & $\{\true\}$ & $\{\false\}$ & $\{\mnull\}$ \\
        $\mnull$ & $\{\true\}$ & $\{\mnull\}$ & $\{\mnull\}$ \\
    \end{tabular}
    \label{tab:aaabland}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{c|ccc}
        $\aaab{\neg}$ & $\true$ & $\false$ & $\mnull$ \\
        \hline
        $\true$ & $\{\false\}$ & $\{\true\}$ & $\{\mnull\}$ \\
    \end{tabular}
    \label{tab:aaabneg}
\end{table}



\autoref{eq:aaabcomp}, \autoref{eq:aaabcomp2}, and \autoref{eq:aaabcomp3}describe the general description of how SQAAL handels comparison operations for regular expressions and ranges. Where the comparison operations work by looking at the entirety of the range or regular expressions and give back a set of true and/or false values.
Since there can be cases where regular expression or ranges are identical, have some overlap or are completely different, the comparison operations can return multiple values.


For regular expressions $R, R_1, R_2$, ranges over one variable $N, N_1, N_2$ and arbitrary values $X$:

\begin{align} \label{eq:aaabcomp}
    X_1 \;\aab{=}\; X_2 &= \begin{cases}
        \begin{cases}
        \{\true \} & \text{if } |X_1| = |X_2| = 1 \land X_1 = X_2 \\
        \{\false\} & \text{if } X_1 \cap X_2 = \emptyset \\
        \{\true, \false\} & \text{if } X_1 \cap X_2 \neq \emptyset
        \end{cases} & \text{if $X_1$ and $X_2$ is of the same type} \\
        \text{undefined} & \text{otherwise} 
    \end{cases} \\
\end{align}

\begin{align}\label{eq:aaabcomp2}
    I_1 \;\aab{<}\; I_2 &= \begin{cases}
        \{\true\} & \text{if } \max(X_1) < \min(X_2) \\
        \{\false\} & \text{if } \max(X_2) \leq \min (X_1) \\
        \{\true, \false\} & \text{otherwise}
    \end{cases}
\end{align}

\begin{align}\label{eq:aaabcomp3}
    I_1 \;\aab{\leq}\; I_2 &= \begin{cases}
        \{\true\} & \text{if } \max(X_1) \leq \min(X_2) \\
        \{\false\} & \text{if } \max(X_2) < \min (X_1) \\
        \{\true, \false\} & \text{otherwise}
    \end{cases}
\end{align}

\subsubsection{Abstract Semantics of Expressions}

Here we define the abstract semantics of expressions in SQAAL.
The first rules guide the semantics of numbers, strings, and variables.
We describe numbers as ranges, strings as regular expressions, and variables as values in the abstract environment.
\autoref{eq:exp-lookup} describes how to look up a variable in the abstract environment, we check if the variable is in the domain of the database environment and if the attribute is in the attribute set of the table.
\autoref{eq:unary-op} and \autoref{eq:binary-op} describe the semantics of unary and binary operations on expressions.

\begin{align}
    \absexpsem{n}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \{ \{ [n, n] \} \}\\
    \absexpsem{k}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \{ R \} \text{ such that }\mathcal{L}(R) = \{ k \} \\
    \absexpsem{v_a}(\rho_{\ab{d}}, \rho_{\ab{a}}) &=  \rho_{\ab{a}}(v_a) \\
    \absexpsem{v_d}(\rho_{\ab{d}}, \rho_{\ab{a}}) &=  \rho_{\ab{t}}(v_d) \text{ such that } \ab{t} \in dom(\ab{d}) \text{ and } v_d \in attr(\ab{t}) \\ \label{eq:exp-lookup}
    \absexpsem{op \; e}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{op} \; (\absexpsem{e}(\rho_{\ab{d}}, \rho_{\ab{a}})) \\ \label{eq:unary-op}
    \absexpsem{e_1 \; op \; e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absexpsem{e}(\rho_{\ab{d}}, \rho_{\ab{a}}) \;\ab{op}\; \absexpsem{e}(\rho_{\ab{d}}, \rho_{\ab{a}})\\ \label{eq:binary-op}
\end{align}

We define the length of a regular expression $R$, $\|R\|$:
These semantic rules describe how to calculate the length of a regular expression.
The length of a regular expression is a range of integers, where the minimum is the length of the shortest string in the language of the regular expression, and the maximum is the length of the longest string in the language of the regular expression.
\begin{align}
    \|R\| = \begin{cases}
        \{ [\|\min(R)\|, \|\max(R)\|] \} & \text{if $\|\max(R)\|$ is defined} \\
        % todo uncomment this
        % \{ \left[ \|\min(R)\|, +\infty \right) \} & \text{if $\|\max(R)\|$ is undefined}
    \end{cases}
\end{align}

\begin{align}
    \|\min(R)\| &= \min\{ \|s\| \mid s \in R \} \\
    \|\max(R)\| &= \max\{ \|s\| \mid s \in R \} \\
    \text{where $\|s\|$ is the length of the word $s$}
\end{align}

these semantic rules describe how we do operations on regular expressions.
\autoref{eq:complement} describes how to take the complement of a regular expression, we make an automata of the regular expression and take the complement of that automata, this is to be sure the regular expression only takes the alphabet of the original regular expression.

\begin{align}
    cvt(op, R_1 \cup R_2) &= cvt(op, R_1) \cup cvt(op, R_2) \\
    cvt(op, R_1 \cap R_2) &= cvt(op, R_1) \cap cvt(op, R_2) \\
    cvt(op, R_1R_2) &= cvt(op, R_1) \; cvt(op, R_2) \\
    cvt(op, R) &= (cvt(op, R))^\star \\
    cvt(op, \overline{R}) &= cvt(op, (\mathcal{R} \circ \mathcal{A}) (\overline{R})) \\ \label{eq:complement}
    cvt(op, \sigma) &= op(\sigma)
\end{align}

\autoref{eq:concat} describes how to concatenate two regular expressions.

\begin{align}
    R_1 \;\aab{||}\; R_2 &= R_1R_2 \\ \label{eq:concat}
    \aab{lower}(R) &= cvt(\sigma \mapsto \sigma', R) \text{ such that $\sigma'$ is the lowercase representation of $\sigma$}\\
    \aab{upper}(R) &= cvt(\sigma \mapsto \sigma', R) \text{ such that $\sigma'$ is the uppercase representation of $\sigma$}\\
    \aab{bit\_length}(R) &= \|cvt(\sigma \mapsto \sigma', R)\| \text{ such that $\sigma'$ is the bit string of $\sigma$} \\
    \aab{length}(R) &= \|R\|
\end{align}

\autoref{eq:abstractBOP} describes how to do binary operations on integers.

\begin{align}
    I_1 \;\aab{aop}\; I_2 &= m(\{i_1 \; aop \; i_2 \mid i_1 \in I_1 \land i_2 \in I_2\}) \\  \label{eq:abstractBOP}
\end{align}

\subsubsection{Abstract Semantics of Predicates}
The base rule of all the predicates is defined in \autoref{eq:atomicformulas}, as this is the base case for all the other predicates, it takes an atomic formula $a_f$ and returns the boolean value of $a_f$.
The other predicates all build on this base case with rules such as negation, disjunction and conjunction.
\begin{align}
    \abspredsem{a_f}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absboolsem{a_f}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\ \label{eq:atomicformulas}
    \abspredsem{\neg \phi}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{\neg} \left( \abspredsem{\phi}(\rho_{\ab{d}}, \rho_{\ab{a}}) \right) \\
    \abspredsem{\phi_1 \lor \phi_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \abspredsem{\phi_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ab{\lor} \abspredsem{\phi_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \abspredsem{\phi_1 \land \phi_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \abspredsem{\phi_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ab{\land} \abspredsem{\phi_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \abspredsem{\exists x \; \phi}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \underset{s \in \absexpsem{x}}{\ab{\bigvee}} \abspredsem{\phi[s/x]} \\
    \abspredsem{\forall x \; \phi}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \underset{s \in \absexpsem{x}}{\ab{\bigwedge}} \abspredsem{\phi[s/x]}
\end{align}

\subsubsection{Abstract Semantics of SQL statements}

Let
\begin{equation}
    \mathcal{C} : \mathbb{V}_a \cup \mathbb{V}_d \rightarrow \{ C_{X_1}(S_1), C_{X_2}(S_2), \dots, C_{X_n}(S_n) \}
\end{equation}
and
\begin{align}
    \abstable \downarrow_{\true} \phi &= \{ l \in \ab{t} \mid \{\{ \true \}\} = \abspredsem{\phi[\pi_{\mathbf{v}_d}(l)/\mathbf{v}_d]} \} \\
    \abstable \downarrow_{\false} \phi &= \{ l \in \ab{t} \mid \{\{ \false \}\} = \abspredsem{\phi[\pi_{\mathbf{v}_d}(l)/\mathbf{v}_d]} \} \\
    \abstable \downarrow_{\unknown} \phi &= \{ l \in \ab{t} \mid \{\{ \true \}\} \neq \abspredsem{\phi[\pi_{\mathbf{v}_d}(l)/\mathbf{v}_d]} \land \{\{ \false \}\} \neq \abspredsem{\phi[\pi_{\mathbf{v}_d}(l)/\mathbf{v}_d]}\} \\
\end{align}

\begin{align}
    \abssqlsem{\langle C_{insert}, \phi \rangle}(\rho_{\ab{d}}, \rho_{\ab{a}}) & =
    \abssqlsem{\langle insert(\mathbf{v}_d, \mathbf{e}), \phi \rangle}(\rho_{\ab{t}}, \rho_{\ab{a}})\\
    & = (\rho_{\ab{t} \cup s}, \rho_{\ab{a}}) \\
    \text{where } target(C_{insert})        & = \ab{t}                                                                                                                                                 \\
    \mathbf{v}_d              & = \langle a_1, a_2, \dots, a_n \rangle                                                                                                        \\
                                               & = attr(\ab{t})                                                                                                                                           \\
    \mathbf{e} & = \langle e_1, e_2, \dots, e_n \rangle \\
    s &= \{ (s_1/a_1, s_2/a_2, \dots, s_n/a_n) \mid (s_1, s_2, \dots, s_n) \in \bigtimes_{i = 1}^{n} \left( \absexpsem{e_i}(\rho_{\ab{d}}, \rho_{\ab{a}}) \into \lookupcl(a_i) \right) \}
\end{align}


\begin{align}
    \abssqlsem{C_{update}}(\env{\abstable}, \env{\absvars})
                                              & = \abssqlsem{\langle update(\absattrs, \absexps), \abspred \rangle} (\env{\abstable}, \env{\absvars}) \\
                                              & = (\env{\abstable'}, \env{\absvars})                                                                 \\
    \text{where } \env{\abstable'}(\absattr) & =
    \begin{cases}
        \env{\abstable \downarrow_{\true} \abspred}(\absattr) \cup \env{\abstable \downarrow_{\unknown} \abspred}(\absattr) \cup \env{\abstable \downarrow_{\false} \abspred}(\absattr) & \text{if } \absattr \notin \absattrs \\
        \left( \absexpsem{\absexp{i}}(\env{\abstable \downarrow_{\true} \abspred}, \env{\absvars}) \cup
        \absexpsem{\absexp{i}}(\env{\abstable \downarrow_{\unknown} \abspred}, \env{\absvars}) \cup \env{\abstable \downarrow_{\unknown} \abspred}(\absattr) \cup \env{\abstable \downarrow_{\false} \abspred}(\absattr) \right) \into \lookupcl(v_{d})\\
        \text{if $\absattr$ is the $i$th component of $\absattrs$ and $\absexp{i}$ is the $i$th componenet of $\absexps$} \\
    \end{cases}
\end{align}

\begin{align*}
    \abssqlsem{C_{delete}}(\env{\abstable}, \env{\absvars})
    &= \abssqlsem{\langle delete(\absattrs), \abspred \rangle} (\env{\abstable}, \env{\absvars}) \\
    &= (\env{\abstable'}, \env{\absvars}) \\
    \text{where } \env{\abstable'}(\absattr) &= \left( \env{\abstable \downarrow_{\unknown} \abspred}(\absattr) \cup \env{\abstable \downarrow_{\false} \abspred}(\absattr) \right) \into \lookupcl(v_d)
\end{align*}

\subsubsection{Abstract Semantics of Actions}

Let $\ab{P}$ be a set of abstract environments $(\env{\abstable}, \env{\absvars})$.

\begin{align}
    \abssem{\texttt{skip}}(\ab{P}) &= \ab{P} \\
    \abssem{v_a := e}(\ab{P}) &= \{(\env{\abstable}, \env{\absvars}[v_a \mapsto s']) \mid (\env{\abstable}, \env{\absvars}) \in \ab{P} \land s = \absexpsem{e}(\env{\abstable}, \env{\absvars}) \land s' = s \into \lookupcl(v_a) \} \\
    \abssem{v_a := \; ?}(\ab{P}) &= \{(\env{\abstable}, \env{\absvars}[v_a \mapsto \top]) \mid (\env{\abstable}, \env{\absvars}) \in \ab{P} \} \\
    \abssem{b}(\ab{P}) &= \{ (\env{\abstable}, \env{\absvars}) \in \ab{P} \mid \true \in B \land B \in \absboolsem{b}(\env{\abstable}, \env{\absvars}) \} \\
    \abssem{C_{sql}}(\ab{P}) &= \{\abssqlsem{C_{sql}}(\env{\abstable}, \env{\absvars}) \mid (\env{\abstable}, \env{\absvars}) \in \ab{P} \}
\end{align}

\begin{restatable}{theorem}{csql}\label{thm:csql}
    $S\llbracket C_{sql}\rrbracket(\widehat{P})$ is a monotone function in a complete lattice
\end{restatable}

% \begin{align*}
%     E^\# \llbracket R_1 \texttt{||} R_2 \rrbracket                          \\
%     = E^\# \llbracket R_1 \rrbracket \oplus  E^\# \llbracket R_2 \rrbracket \\
%     \text{where } R_1 \text{ and } R_2 \text{ are regular expressions and } \\
%     \oplus \text{ is the concatenation operator.}
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{bit\_length} (R) \rrbracket \\
%     =  [length(B(s)), length(B(S))]                     \\
%     bit\_length \text{ returns a range of the binary}   \\
%     \text{ representation of regular expression } R.    \\
%     \text{where } B(s) \text{ is the binary representation of }s
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{char\_length} (R) \rrbracket       \\
%     =  [length(s), lenght(S)]                                  \\
%     char\_length \text{ returns a range of the shortest and}   \\
%     \text{ longest string created from the regular expression} \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{lower} (c) \rrbracket =c'                                                    \\
%     E^\# \llbracket \texttt{lower}(R_1 \cup R_2) \rrbracket                                              \\
%     = E^\# \llbracket \texttt{lower}(R_1) \rrbracket \cup E^\# \llbracket \texttt{lower}(R_2) \rrbracket \\
%     E^\# \llbracket \texttt{lower}(R_1 \cap R_2) \rrbracket                                              \\
%     = E^\# \llbracket \texttt{lower}(R_1) \rrbracket \cap E^\# \llbracket \texttt{lower}(R_2) \rrbracket \\
%     E^\# \llbracket \texttt{lower}(R_1^*) \rrbracket                                                     \\
%     = E^\# \llbracket \texttt{lower}(R_1)^* \rrbracket                                                   \\
%     \text{Where }c \in \Sigma \text{ and } c' \text{ is the lower case of } c.                           \\
%     R_1 \text{ and } R_2 \text{ are regular expressions.}                                                \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{upper}(R) \rrbracket \\
%     \text{Where upper is the same as lower but converts to upper case.}
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{position}(R_1, in, R_2) \rrbracket \\
%     = I                                             \\
%     \text{where } R1 \text{ and } R2 \text{ are regular expressions and }
%     I \text{ is an integer.}                        \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{sub\_string} (R, I_1, I_2) \rrbracket \\
%     = []                                                          \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{trim} ('pos', R_1 \text{ from } R_2) \rrbracket                            \\
%     =  \texttt{trim}('pos', R_1 \text{ from } R_2)                                                     \\
%     \texttt{trim} \text{ removes all leading, trailing or both occurrences of } R_2 \text{ from } R_1. \\
%     \text{where } R_1 \text{ and } E_2 \text{ are regular expressions, and 'pos' is a string.}         \\
% \end{align*}
%
% \todo[inline]{Casper says:
%     For the tree definitions above a definition should be give for position, substring and trim.
%     We should be able to implement the abstract semantics by following the semantics above.
% }
%
% \subsection{Abstract Interpretation of belongs}
% To provide a precise definition of the belongs function, envision a lattice composed of partitions of a language. We aim to identify the most precise partition that encompasses a given expression. In essence, we seek to pinpoint which element in the lattice accurately describes the expression's location. Simply stating that it resides somewhere within the entire set would lack practicality.
%
% Partitions within this lattice may overlap, symbolizing intersections of languages. The lattice itself is complete, with the top element representing the entire set of languages, and the bottom element indicating the empty set.
%
% Navigating this lattice involves starting from the top and descending until we reach a point where no partitions cover the expression. At this juncture, we have identified the most precise set of partitions that encompass the expression.
%
% $ belongs(x)=\bigsqcap\{x' \mid x \sqsubseteq x', x' \in X\} $
% Taking an expression $x$, we seek to identify the most precise partition that encompasses it. We do this by finding the greatest lowerbound of all partitions that contain $x$.
% % todo same as above
%
% % \begin{restatable}{lemma}{updatemonotone}
% %     $\abssem{C_{update}^\#}$ is monotone.
% % \end{restatable}
% % \pfsketch{
% %     For $\abstable \sqsubseteq \abstablep$ if $\abssem{C_{update}^\#}$ updates elements in $\abstable$ the same elements must be updated in $\abstablep$, therefore the order is determined by the remaining unchanged elements and therefore order is preserved.
% %     If an element not in $\abstable$ is update is changed in $\abstablep$ order is still preserved as the element is 'swapped' for another.
% % }
