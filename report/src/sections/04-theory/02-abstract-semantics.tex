\subsection{Abstract Syntax} \label{subsec:function-definitions}

\todo[inline]{Lars says: Write the tables in from the paper:Abstract interpretation of database query languages}
\begin{center}
    \begin{tabular}{l l}
        $n: \mathbb{Z}$                          & Integer                                                   \\
        $k: \S$                                  & String                                                    \\
        $c: \mathbb{C}$                          & Constants                                                 \\
        $v_a: \mathbb{V}_a$                      & Application variables                                     \\
        $v_d: \mathbb{V}_d$                      & Database variables (attributes) involved in SQL commands  \\
        $v: \mathbb{V} \triangleq \mathbb{V}_d $ & Variables                                                 \\
        $e: \mathbb{E}$                          & Arithmetic expressions                                    \\
        $b: \mathbb{B}$                          & Boolean expressions                                       \\
        $A_{sql}: \mathbb{A}_{sql}$              & Action part of SQL commands                               \\
        $\tau: \mathbb{T}$                       & Terms                                                     \\
        $a_f: \mathbb{A}_f$                      & Atomic formulas                                           \\
        $\phi : \mathbb{W}$                      & Well-formed formulas (pre-condition part of SQL commands) \\
        $C_{sql}: \mathbb{C}_{sql}$              & SQL commands                                              \\
        $I: \mathbb{I}$                          & Instructions/commands                                     \\
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{l l}
        $c ::=$ & $n \mid k$ \\
        $e ::=$ & $c \mid v_d \mid v_a \mid ap_u e \mid e_1 op_b e_2$ , where $op_u$ and $op_b$ represent unary and binary arithmetic operations respectively. \\
        $e ::=$ & $e_1 = e_2 \mid e_1 \geq \mid e_1 \leq e_2 \mid e_1 > e_2 \mid e_1 < e_2 \mid e_1 \neq e_2 \mid \neg b \mid b_1 \lor b_2 \mid b_1 \land b_2 \mid \texttt{true} \mid \texttt{flase}$ \\
        $\tau ::=$ & $c \mid v_a \mid v_d \mid f_n(\tau_1, \tau_2, \dots, \tau_n)$, where $f_n$ is an $n$-any function. \\
        $a_f ::=$ & $R_n(\tau_1, \tau_2, \dots, \tau_n) \mid \tau_1 = \tau2$, where $R_n$ is an $n$-ary relation: $R_n(\tau_1, \tau_2, \dots, \tau_n) \in \{ \texttt{true}, \texttt{false}\}$ \\
        $\phi ::=$ & $a_f \mid \neg \phi_1 \mid \phi_1 \lor \phi_2 \mid \phi_1 \land \phi_2 \mid \forall \textbf{x}_i \phi \mid \exists \textbf{x}_i \phi$ \\
        $A_{sql} :: =$ & $select(v_a) \mid update(v_d, e) \mid delete(v_d) \mid insert(v_d, e)$ \\
        $C_{sql} ::=$ & $\langle A_{sql}, \phi \rangle $ \\
        $I ::=$ & $skip \mid v_a := e \mid v_a := ? \mid C_{sql} $\\
    \end{tabular}
\end{center}


\subsection{Abstract Semantics}\label{subsec:abstract-semantics}
\todo[inline]{Lars says: We should add a glossary for SQAAL}
This section will describe to abstract semantics of SQAAL.
% In general, this paper represents strings as a list of characters.

We would like to distinguish between single values and lists of values, thus we define algebraic type:
\begin{align}
    \mathsf{Val} \; v ::= \mathsf{Single} \; v \mid \mathsf{List} \; \mathcal{P}(v)
\end{align}

In \autoref{eq:generalBOP} and \autoref{eq:generalUOP} we see the how the general binary and unary operation works in SQAAL.
We denote binary operations on sets with $\widehat{op}$, and $\aab{op}$ for binary operations on elements in those sets.

\begin{align}\label{eq:generalBOP}
    \mathsf{Single} \; s_1 \aop \mathsf{Single} \; s_2 &= \mathsf{Single} \; (s_1 \aaop s_2) \\
    \mathsf{Single} \; s \aop \mathsf{List} \; S &= \mathsf{List} \; \{ s \aaop s' \mid s' \in S \}  \\
    \mathsf{List} \; S \aop \mathsf{Single} \; s &= \mathsf{List} \; \{ s' \aaop s \mid s' \in S \}  \\
    \mathsf{List} \; S_1 \aop \mathsf{List} \; S_2 &= \mathsf{List} \; \{ s_1 \aaop s_2 \mid s_1 \in S_1, s_2 \in S_2 \} \\
    \aop (\mathsf{Single} \; s) &= \mathsf{Single} \; (\aaop s) \\
    \aop (\mathsf{List} \; S) &= \mathsf{List} \; \{ \aaop s \mid s \in S \}
\end{align}

\subsubsection{Abstract Semantics of Boolean expressions}
We now define the general abstract semantics of boolean expressions.
$\aab{bop}$ is defined to be a special case of $\aaop$ as follows:
\begin{align}
    B_1 \;\aab{bop}\; B_2 = \bigcup_{b_1 \in B_2, b_2 \in B_2} b_1 \;\aaab{bop}\; b_2
\end{align}
Where $\aaab{bop}$ is defined for $\land$, $\lor$ and $\neg$ in \autoref{tab:aaabland}, \autoref{tab:aaablor} and \autoref{tab:aaabneg} respectively.

Equation \ref{eq:abstract-bool-semantics-start} through \ref{eq:abstract-bool-semantics-end2} shows the abstract semantics of boolean expressions, such as logical operators and comparisons between expressions.
Boolean expressions are evaluated recursively on in relation to the current state of the program.
In general we don't know whether a comparison is between a single value or a list of values, thus we assume the former and take the prior as a special case that we can't distinguish.
Therefore Boolean expressions over abstracts values evaluate to abstract lists of Boolean values.

\begin{align}
    \absboolsem{\texttt{true}}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \mathsf{Single} \; \{\true\} \label{eq:abstract-bool-semantics-start} \\
    \absboolsem{\texttt{false}}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \mathsf{Single} \; \{\false\} \\
    \absboolsem{b_1 \lor b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absboolsem{b_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ab{\lor} \absboolsem{b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \absboolsem{b_1 \land b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absboolsem{b_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ab{\land} \absboolsem{b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \absboolsem{\neg b}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{\neg} \absboolsem{b}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \absboolsem{e_1 \neq e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{\neg}(\absexpsem{e_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \;\ab{=}\; \absexpsem{e_2}(\rho_{\ab{d}}, \rho_{\ab{a}})) \label{eq:abstract-bool-semantics-end1} \\
    \absboolsem{e_1 \;comp\; e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &=
    \begin{cases}
        \mathsf{List} \; \left(S' \cup \{\{null\}\} \right) & \text{if } E_1 = \mathsf{List} \; S_1 \land E_2 = \mathsf{List} \; S_2 \land E_1 \;\ab{\comp}\; E_2 = \mathsf{List} \; S'\\
        E_1 \;\ab{\comp}\; E_2 & \text{otherwise}\\
    \end{cases}\label{eq:abstract-bool-semantics-end2} \\
    \text{where } & E_1 = \absexpsem{e_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \text{and } & E_2 = \absexpsem{e_2}(\rho_{\ab{d}}, \rho_{\ab{a}})
\end{align}

\begin{table}[H]
    \centering
    \caption{test}
    \begin{tabular}{c|ccc}
        $\aaab{\land}$ & $\true$ & $\false$ & $\mnull$ \\
        \hline
        $\true$ & $\{\true\}$ & $\{\false\}$ & $\{\mnull\}$ \\
        $\false$ & $\{\false\}$ & $\{\false\}$ & $\{\false\}$ \\
        $\mnull$ & $\{\mnull\}$ & $\{\false\}$ & $\{\mnull\}$ \\
    \end{tabular}
    \label{tab:aaabland}
\end{table}

\begin{table}[H]
    \centering
    \caption{test}
    \begin{tabular}{c|ccc}
        $\aaab{\lor}$ & $\true$ & $\false$ & $\mnull$ \\
        \hline
        $\true$ & $\{\true\}$ & $\{\true\}$ & $\{\true\}$ \\
        $\false$ & $\{\true\}$ & $\{\false\}$ & $\{\mnull\}$ \\
        $\mnull$ & $\{\true\}$ & $\{\mnull\}$ & $\{\mnull\}$ \\
    \end{tabular}
    \label{tab:aaablor}
\end{table}

\begin{table}[H]
    \centering
    \caption{test}
    \begin{tabular}{c|ccc}
        $\aaab{\neg}$ & $\true$ & $\false$ & $\mnull$ \\
        \hline
        $\true$ & $\{\false\}$ & $\{\true\}$ & $\{\mnull\}$ \\
    \end{tabular}
    \label{tab:aaabneg}
\end{table}

Equation \ref{eq:aaabcomp} through \ref{eq:aaabcomp3} describe how SQAAL handles comparison operations for abstract strings (regular expressions) and numbers (union of interval).
Where the comparison operations work by looking at the entirety of the range or regular expressions and give back a set of true and/or false values.
Since there can be cases where regular expressions or ranges are identical, have some overlap or are completely different, the comparison operations can return multiple values.


For ranges $I_1$ and $I_2$ and arbitrary values $X_1$ and $X_2$ (either a intervals or a regular expression):

\begin{align} \label{eq:aaabcomp}
    X_1 \;\aab{=}\; X_2 &= \begin{cases}
        \begin{cases}
        \{\true\} & \text{if } |X_1| = |X_2| = 1 \\
        \{\false\} & \text{if } X_1 \cap X_2 = \emptyset \\
        \{\true, \false\} & \text{if } X_1 \cap X_2 \neq \emptyset
        \end{cases} & \text{if $X_1$ and $X_2$ is of the same type} \\
        \text{undefined} & \text{otherwise}
    \end{cases}
\end{align}

\begin{align}\label{eq:aaabcomp2}
    I_1 \;\aab{<}\; I_2 &= \begin{cases}
        \{\true\} & \text{if } \max(I_1) < \min(I_2) \\
        \{\false\} & \text{if } \max(I_2) \leq \min (I_1) \\
        \{\true, \false\} & \text{otherwise}
    \end{cases}
\end{align}

\begin{align}\label{eq:aaabcomp3}
    I_1 \;\aab{\leq}\; I_2 &= \begin{cases}
        \{\true\} & \text{if } \max(I_1) \leq \min(I_2) \\
        \{\false\} & \text{if } \max(I_2) < \min (I_1) \\
        \{\true, \false\} & \text{otherwise}
    \end{cases}
\end{align}

\subsubsection{Abstract Semantics of Expressions}

Here we define the abstract semantics of expressions in SQAAL.

\autoref{sem:exp1} to \ref{sem:exp2} describe the semantics of constants.
In \autoref{sem:exp3} to \ref{sem:exp4} we describe the semantics of variables.
In the case of database variables in \autoref{sem:exp4}, we assume attribute names do not clash.
\autoref{eq:exp-lookup} and \autoref{eq:unary-op} describe the semantics of unary and binary operations on expressions.

\begin{align}\label{sem:exp1}
    \absexpsem{n}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \mathsf{Single} \; \{ [n, n] \} \\\label{sem:exp2}
    \absexpsem{k}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \mathsf{Single} \; R,  \text{ such that }\mathcal{L}(R) = \{ k \} \\ \label{sem:exp3}
    \absexpsem{v_a}(\rho_{\ab{d}}, \rho_{\ab{a}}) &=  \rho_{\ab{a}}(v_a) \\ \label{sem:exp4}
    \absexpsem{v_d}(\rho_{\ab{d}}, \rho_{\ab{a}}) &=  \rho_{\ab{t}}(v_d) \text{ such that } \ab{t} \in dom(\ab{d}) \text{ and } v_d \in attr(\ab{t}) \\ \label{eq:exp-lookup}
    \absexpsem{op \; e}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{op} \; (\absexpsem{e}(\rho_{\ab{d}}, \rho_{\ab{a}})) \\ \label{eq:unary-op}
    \absexpsem{e_1 \;op\; e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &=
    \begin{cases}
        \mathsf{List} \; \left(S' \cup \{\{null\}\} \right) & \text{if } E_1 = \mathsf{List} \; S_1 \land E_2 = \mathsf{List} \; S_2 \land E_1 \;\ab{op}\; E_2 = \mathsf{List} \; S'\\
        E_1 \;\ab{op}\; E_2 & \text{otherwise}\\
    \end{cases} \\
    \text{where } & E_1 = \absexpsem{e_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \text{and } & E_2 = \absexpsem{e_2}(\rho_{\ab{d}}, \rho_{\ab{a}})
\end{align}

Before defining the abstract operations, $\aaop$, for expressions, we will define some auxiliary functions.
We define the length of a regular expression $R$, $\|R\|$:
\begin{align}\label{eq:r1}
    \|R\| & = \{ \left[ \|\min(R)\|, +\infty \right) \} \\
    \text{where } & \|\min(R)\| = \min\{ \|s\| \mid s \in R \} \\ \label{eq:r2}
    \text{and } & \|s\| \text{ is the length of the word $s$}
\end{align}

We can find $\min(R)$ in \autoref{eq:r1} from the initial state to any final state by the shortest path algorithm.

Next, we define $cvt$ which is String conversion generalized to regular expressions, defined by recursing on the operands of union, intersection, concatenation and kleene star.
In the base case, a single symbol is converted as defined by $op$.
In the case of the complement, seen in \autoref{eq:complement}, we convert $\overline{R}$ to its DFA equivalent by the usual construction, $\mathcal{A}:REG\rightarrow DFA$. \todo{reference to Sipser}
This automaton is then converted back to a regular expression by the usual GNFA construction, $\mathcal{R}: DFA\rightarrow REG$, thus eliminating the complement. \todo{reference to Sipser}

\begin{align}
    cvt(op, R_1 \cup R_2) &= cvt(op, R_1) \cup cvt(op, R_2) \\
    cvt(op, R_1 \cap R_2) &= cvt(op, R_1) \cap cvt(op, R_2) \\
    cvt(op, R_1R_2) &= cvt(op, R_1) \; cvt(op, R_2) \\
    cvt(op, R^\star) &= (cvt(op, R))^\star \\
    cvt(op, \overline{R}) &= cvt(op, (\mathcal{R} \circ \mathcal{A}) (\overline{R})) \\ \label{eq:complement}
    cvt(op, \sigma) &= op(\sigma)
\end{align}

\autoref{eq:concat} to \ref{eq:length} describe a subset of String operators present in PostgreSQL.

\begin{align}\label{eq:concat}
    R_1 \;\aab{||}\; R_2 &= R_1R_2 \\
    \aab{lower}(R) &= cvt(\sigma \mapsto \sigma', R) \text{ such that $\sigma'$ is the lowercase representation of $\sigma$}\\
    \aab{upper}(R) &= cvt(\sigma \mapsto \sigma', R) \text{ such that $\sigma'$ is the uppercase representation of $\sigma$}\\
    \aab{bit\_length}(R) &= \|cvt(\sigma \mapsto \sigma', R)\| \text{ such that $\sigma'$ is the bit string of $\sigma$} \\ \label{eq:length}
    \aab{length}(R) &= \|R\|
\end{align}

\autoref{eq:abstractBOP} describes how to do binary operations on numbers.
The arithmetic operations, $aop$, are defined as the standard for intervals.

\begin{align}
    I_1 \;\aab{aop}\; I_2 &= m(\{i_1 \; aop \; i_2 \mid i_1 \in I_1 \land i_2 \in I_2\})  \label{eq:abstractBOP}
\end{align}

\subsubsection{Abstract Semantics of Predicates}
The base rule of all the predicates is defined in \autoref{eq:atomicformulas}, as this is the base case for all the other predicates.
It takes atomic formulas, $a_f$, of the form corresponding to \autoref{eq:abstract-bool-semantics-end1} and \ref{eq:abstract-bool-semantics-end2}, and returns the boolean value of $a_f$.
The other predicates all build on this base case with rules such as negation, disjunction and conjunction.
\begin{align}\label{eq:atomicformulas}
    \abspredsem{a_f}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absboolsem{a_f}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \abspredsem{\neg \phi}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{\neg} \left( \abspredsem{\phi}(\rho_{\ab{d}}, \rho_{\ab{a}}) \right) \\
    \abspredsem{\phi_1 \lor \phi_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \abspredsem{\phi_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ab{\lor} \abspredsem{\phi_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \abspredsem{\phi_1 \land \phi_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \abspredsem{\phi_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ab{\land} \abspredsem{\phi_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \abspredsem{\exists x_i \; \phi}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \underset{s \in \absexpsem{x}}{\ab{\bigvee}} \abspredsem{\phi[s/x_i]} \\
    \abspredsem{\forall x_i \; \phi}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \underset{s \in \absexpsem{x}}{\ab{\bigwedge}} \abspredsem{\phi[s/x_i]}
\end{align}

\subsubsection{Abstract Semantics of SQL statements}

Let
\begin{equation}
    \mathcal{C} : \mathbb{V}_a \cup \mathbb{V}_d \rightarrow \{ C_{X_1}(S_1), C_{X_2}(S_2), \dots, C_{X_n}(S_n) \}
\end{equation}
where $X_1,...,X_n$ are defined as in \autoref{def:coverlattice} and are provided by the user.
Also $S_1,...,S_n$ are given by the type of $v_a$ and $v_d$.

Let
\begin{align}
    \abstable \downarrow_{\true} \phi &= \{ l \in \ab{t} \mid \mathsf{Single} \; \{ \true \} = \abspredsem{\phi[(\mathsf{Single} \; (\pi_{\mathbf{v}_d}(l)))/\mathbf{v}_d]} \text{ for } \mathbf{v}_d = var_d(\phi) \} \\
    \abstable \downarrow_{\false} \phi &= \{ l \in \ab{t} \mid \mathsf{Single} \; \{ \false \} = \abspredsem{\phi[(\mathsf{Single} \; (\pi_{\mathbf{v}_d}(l)))/\mathbf{v}_d]} \text{ for } \mathbf{v}_d = var_d(\phi) \} \\
    \abstable \downarrow_{\unknown} \phi &= \{ l \in \ab{t} \mid \mathsf{Single} \; b = \abspredsem{\phi[(\mathsf{Single} \; (\pi_{\mathbf{v}_d}(l)))/\mathbf{v}_d]} \text{ such that } \true \in b \land 1 < |b|\\ &\text{ or }  \mathsf{List} \; B = \abspredsem{\phi[(\mathsf{Single} \; (\pi_{\mathbf{v}_d}(l)))/\mathbf{v}_d]} \text{ such that } \true \in b \land b \in B \text{ for } \mathbf{v}_d = var_d(\phi) \}
\end{align}

\begin{align}
    \abssqlsem{\langle select(v_a), \phi \rangle}(\rho_{\ab{d}}, \rho_{\ab{a}})
    &= (\rho_{\ab{d}}, \rho_{\ab{a}}[v_a \mapsto \left( \mathsf{List} \left(\abstable \downarrow_{\true} \phi \cup \abstable \downarrow_{\unknown} \phi \right) \right) \into \lookupcl(v_a) ])
\end{align}

\begin{align}
    \abssqlsem{\langle C_{insert}, \phi \rangle}(\rho_{\ab{d}}, \rho_{\ab{a}}) & =
    \abssqlsem{\langle insert(\mathbf{v}_d, \mathbf{e}), \phi \rangle}(\rho_{\ab{t}}, \rho_{\ab{a}})\\
    & = (\rho_{\ab{t} \cup s}, \rho_{\ab{a}}) \\
    \text{where }& s = \bigtimes_{i = 0}^{n} unwrap\left( \absexpsem{e_i}(\rho_{\ab{d}}, \rho_{\ab{a}}) \right) \into \lookupcl(v_i) \\
    \text{and }& target(C_{insert}) = \ab{t}
\end{align}

\begin{align}
    unwrap &: \mathsf{Val} \; a  \rightarrow \mathcal{P}(a) \\
    unwrap &\;(\mathsf{Single} \; x) = \{x\} \\
    unwrap &\;(\mathsf{List} \; x) = x
\end{align}


\begin{align}
    \abssqlsem{C_{update}}(\env{\abstable}, \env{\absvars})
                                              & = \abssqlsem{\langle update(\absattrs, \absexps), \abspred \rangle} (\env{\abstable}, \env{\absvars}) \\
                                              & = (\env{\ab{t}'}, \env{\absvars})
\end{align}

\begin{align}
    \text{where } \abstable' = \ab{t} \downarrow_{\false} \phi
    & \cup \left\{ l\left[ \mathbf{v}_d \mapsto \pi_{\mathbf{v}_d}(s) \sqcup \pi_{\mathbf{v}_d}(l) \right] \;\middle|\; l \in \ab{t} \downarrow_{\unknown} \phi \land s \in \bigtimes_{i = 0}^{n} unwrap\left( \absexpsem{e_i}(\rho_{\ab{d}}, \rho_{\ab{a}}) \right) \into \lookupcl(v_i)\right\} \\
    & \cup \left\{ l\left[ \mathbf{v}_d \mapsto \pi_{\mathbf{v}_d}(s) \right] \;\middle|\; l \in \ab{t} \downarrow_{\true} \phi \land s \in \bigtimes_{i = 0}^{n} unwrap\left( \absexpsem{e_i}(\rho_{\ab{d}}, \rho_{\ab{a}}) \right) \into \lookupcl(v_i)\right\} \\
\end{align}

\begin{align*}
    \abssqlsem{C_{delete}}(\env{\abstable}, \env{\absvars})
    &= \abssqlsem{\langle delete(\absattrs), \abspred \rangle} (\env{\abstable}, \env{\absvars}) \\
    &= (\env{\abstable'}, \env{\absvars}) \\
    \text{where } \abstable' &= \abstable \downarrow_{\unknown} \phi \cup \abstable \downarrow_{\false} \phi
\end{align*}

\subsubsection{Abstract Semantics of Actions}
This section will cover the abstract semantics of actions in SQAAL.
In general the abstract semantics of actions are defined as a function that takes a set of abstract environments and returns an updated set of abstract environments.
Meaning that when an action is made, the abstract environment is updated to reflect the changes made by the action.
An example of this could be with the skip action, where the abstract environment is not changed.


Let $\ab{P}$ be a set of abstract environments $(\env{\abstable}, \env{\absvars})$.

\begin{align}
    \abssem{\texttt{skip}}(\ab{P}) &= \ab{P} \\
    \abssem{v_a := e}(\ab{P}) &= \{(\env{\abstable}, \env{\absvars}[v_a \mapsto s']) \mid (\env{\abstable}, \env{\absvars}) \in \ab{P} \land s = \absexpsem{e}(\env{\abstable}, \env{\absvars}) \land s' = s \into \lookupcl(v_a) \} \\
    \abssem{v_a := \; ?}(\ab{P}) &= \{(\env{\abstable}, \env{\absvars}[v_a \mapsto \mathsf{Single} \; \top]) \mid (\env{\abstable}, \env{\absvars}) \in \ab{P} \} \\
    \abssem{b}(\ab{P}) &= \{ (\env{\abstable}, \env{\absvars}) \in \ab{P} \mid \true \in B \land B \in \absboolsem{b}(\env{\abstable}, \env{\absvars}) \} \\
    \abssem{C_{sql}}(\ab{P}) &= \{\abssqlsem{C_{sql}}(\env{\abstable}, \env{\absvars}) \mid (\env{\abstable}, \env{\absvars}) \in \ab{P} \}
\end{align}

\begin{restatable}{theorem}{csql}\label{thm:csql}
    $\abssem{I}$ is a monotone function in a complete lattice.
\end{restatable}

% \begin{align*}
%     E^\# \llbracket R_1 \texttt{||} R_2 \rrbracket                          \\
%     = E^\# \llbracket R_1 \rrbracket \oplus  E^\# \llbracket R_2 \rrbracket \\
%     \text{where } R_1 \text{ and } R_2 \text{ are regular expressions and } \\
%     \oplus \text{ is the concatenation operator.}
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{bit\_length} (R) \rrbracket \\
%     =  [length(B(s)), length(B(S))]                     \\
%     bit\_length \text{ returns a range of the binary}   \\
%     \text{ representation of regular expression } R.    \\
%     \text{where } B(s) \text{ is the binary representation of }s
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{char\_length} (R) \rrbracket       \\
%     =  [length(s), lenght(S)]                                  \\
%     char\_length \text{ returns a range of the shortest and}   \\
%     \text{ longest string created from the regular expression} \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{lower} (c) \rrbracket =c'                                                    \\
%     E^\# \llbracket \texttt{lower}(R_1 \cup R_2) \rrbracket                                              \\
%     = E^\# \llbracket \texttt{lower}(R_1) \rrbracket \cup E^\# \llbracket \texttt{lower}(R_2) \rrbracket \\
%     E^\# \llbracket \texttt{lower}(R_1 \cap R_2) \rrbracket                                              \\
%     = E^\# \llbracket \texttt{lower}(R_1) \rrbracket \cap E^\# \llbracket \texttt{lower}(R_2) \rrbracket \\
%     E^\# \llbracket \texttt{lower}(R_1^*) \rrbracket                                                     \\
%     = E^\# \llbracket \texttt{lower}(R_1)^* \rrbracket                                                   \\
%     \text{Where }c \in \Sigma \text{ and } c' \text{ is the lower case of } c.                           \\
%     R_1 \text{ and } R_2 \text{ are regular expressions.}                                                \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{upper}(R) \rrbracket \\
%     \text{Where upper is the same as lower but converts to upper case.}
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{position}(R_1, in, R_2) \rrbracket \\
%     = I                                             \\
%     \text{where } R1 \text{ and } R2 \text{ are regular expressions and }
%     I \text{ is an integer.}                        \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{sub\_string} (R, I_1, I_2) \rrbracket \\
%     = []                                                          \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{trim} ('pos', R_1 \text{ from } R_2) \rrbracket                            \\
%     =  \texttt{trim}('pos', R_1 \text{ from } R_2)                                                     \\
%     \texttt{trim} \text{ removes all leading, trailing or both occurrences of } R_2 \text{ from } R_1. \\
%     \text{where } R_1 \text{ and } E_2 \text{ are regular expressions, and 'pos' is a string.}         \\
% \end{align*}
%
% \todo[inline]{Casper says:
%     For the tree definitions above a definition should be give for position, substring and trim.
%     We should be able to implement the abstract semantics by following the semantics above.
% }
%
% \subsection{Abstract Interpretation of belongs}
% To provide a precise definition of the belongs function, envision a lattice composed of partitions of a language. We aim to identify the most precise partition that encompasses a given expression. In essence, we seek to pinpoint which element in the lattice accurately describes the expression's location. Simply stating that it resides somewhere within the entire set would lack practicality.
%
% Partitions within this lattice may overlap, symbolizing intersections of languages. The lattice itself is complete, with the top element representing the entire set of languages, and the bottom element indicating the empty set.
%
% Navigating this lattice involves starting from the top and descending until we reach a point where no partitions cover the expression. At this juncture, we have identified the most precise set of partitions that encompass the expression.
%
% $ belongs(x)=\bigsqcap\{x' \mid x \sqsubseteq x', x' \in X\} $
% Taking an expression $x$, we seek to identify the most precise partition that encompasses it. We do this by finding the greatest lowerbound of all partitions that contain $x$.
% % todo same as above
%
% % \begin{restatable}{lemma}{updatemonotone}
% %     $\abssem{C_{update}^\#}$ is monotone.
% % \end{restatable}
% % \pfsketch{
% %     For $\abstable \sqsubseteq \abstablep$ if $\abssem{C_{update}^\#}$ updates elements in $\abstable$ the same elements must be updated in $\abstablep$, therefore the order is determined by the remaining unchanged elements and therefore order is preserved.
% %     If an element not in $\abstable$ is update is changed in $\abstablep$ order is still preserved as the element is 'swapped' for another.
% % }
