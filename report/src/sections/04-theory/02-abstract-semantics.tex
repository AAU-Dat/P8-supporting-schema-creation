\subsection{Abstract Semantics}

We extend the semantics described in \cite{halder_abstract_2012}, to encompass our taxonomy of abstract tables.

\begin{align*}
    S^\# \llbracket C_{insert}^\# \rrbracket (t) &= S^\# \llbracket insert(\mathbf{v}_d, e^\#) \rrbracket (t) \\
    &= t \sqcup t' \\
    \text{where } E^\# \llbracket e^\# \rrbracket &= t',
\end{align*}

\begin{lemma}
    $S^\# \llbracket C_{insert}^\# \rrbracket$ is monotone.
    %todo
    \todo{Casper says: needs a proving.}
\end{lemma}

\begin{align*}
    E^\# \llbracket R_1 C_{concatenate}^\# R_2 \rrbracket \\
    = E^\# \llbracket R_1 \rrbracket \oplus  E^\# \llbracket R_2 \rrbracket \\
    \text{where } E^\# \llbracket R \rrbracket \text{ is a regular language and }\\
     \oplus \text{ is the concatenation operator.}
\end{align*}
\todo[inline]{Casper says:
    Why $C_{concatenate}^\#$ and not just $\texttt{||}$?
}

\begin{align*}
    E^\# \llbracket C_{bitLength}^\# (R) \rrbracket \\
    = E^\# \llbracket Count(B(R)) \rrbracket \\
    \text{where } B(R) \text{ is the binary representation of }R, \\ \text{ and Count determines the length.}
\end{align*}
\todo[inline]{Casper says:
    Why not just write $\texttt{bit\_length(} R \texttt{)}$, instead of $C_{bitLength}^\#$?
    How would you derive the binary representation of $R$? What is it? How is it computed?
    I think the way I would do this is by finding the shortest $s$ possible string, and the longest possible string $S$ in $R$ and then produce a range $[l(B(s)), l(B(S))]$ where $l$ is the length of a string and $B$ is the binary representation.

}

\begin{align*}
    E^\# \llbracket C_{charLength}^\# (S) \rrbracket \\
    = E^\# \llbracket Count(S) \rrbracket \\
    \text{where } S \text{ is a string and Count determines the length.}
\end{align*}
\todo[inline]{Casper says:
    Same as above? how do you count the lenght of a regular expression?
}

\begin{align*}
    E^\# \llbracket C_{lower}^\# (S) \rrbracket \\
    = E^\# \llbracket MapToLower (S) \rrbracket \\
    \text{where S is a string and } MapToLower \\
    \text{ converts all characters to lowercase.}
\end{align*}
\todo[inline]{Casper says:
    How does $MapToLower$ work, I would suggest a recursive definition.
}

\begin{align*}
    E^\# \llbracket C_{lower}^\# (S) \rrbracket \\
    = E^\# \llbracket MapToUpper (S) \rrbracket \\
    \text{where S is a string and } MapToUpper \\
    \text{ converts all characters to uppercase.}
\end{align*}
\todo[inline]{Casper says:
    Same as above.
}

\begin{align*}
    E^\# \llbracket C_{position}^\# (S_1, in, S_2) \\
    = E^\# \llbracket Position(S_1, in, S_2) \rrbracket \\
    \text{where S is a string and } Position \\
    \text{ returns the position of the first occurrence of } \\
    S_2 \text{ in } S_1.
\end{align*}

\begin{align*}
    E^\# \llbracket C_{subString}^\# (S, I_1, I_2) \rrbracket \\
    = E^\# \llbracket SubString(S, I_1, I_2) \rrbracket \\
    \text{where } S \text{ is a string, } I \text{ are integers, and } \\
    SubString \text{ returns the substring of } S \text{ from } I_1 \text{ to } I_2.
\end{align*}

\begin{align*}
    E^\# \llbracket C_{trim}^\# (S_1 from S_2) \rrbracket \\
    = E^\# \llbracket Trim(S_1, S_2) \rrbracket \\
    \text{where } S_1 \text{ and } S_2 \text{ are strings, and }\\
    Trim \text{ removes all occurrences of } S_2 \text{ from } S_1.
\end{align*}

\todo[inline]{Casper says:
    For the tree definitions above a definition should be give for position, substring and trim.
    We should be able to implement the abstract semantics by following the semantics above.
}



\subsection{Abstract Interpretation of belongs}
To provide a precise definition of the belongs function, envision a lattice composed of partitions of a language. We aim to identify the most precise partition that encompasses a given expression. In essence, we seek to pinpoint which element in the lattice accurately describes the expression's location. Simply stating that it resides somewhere within the entire set would lack practicality.

Partitions within this lattice may overlap, symbolizing intersections of languages. The lattice itself is complete, with the top element representing the entire set of languages, and the bottom element indicating the empty set.

Navigating this lattice involves starting from the top and descending until we reach a point where no partitions cover the expression. At this juncture, we have identified the most precise set of partitions that encompass the expression.

$ belongs(x)=\bigsqcap\{x' \mid x \sqsubseteq x', x' \in X\} $
Taking an expression $x$, we seek to identify the most precise partition that encompasses it. We do this by finding the greatest lowerbound of all partitions that contain $x$.

