\subsection{Function definitions} \label{subsec:function-definitions}

\todo[inline]{Lars says: Write the tables in from the paper:Abstract interpretation of database query languages}
\begin{center}
    \begin{tabular}{l l}
        $n: \mathbb{Z}$                          & Integer                                                   \\
        $k: \S$                                  & String                                                    \\
        $c: \mathbb{C}$                          & Constants                                                 \\
        $v_a: \mathbb{V}_a$                      & Application variables                                     \\
        $v_d: \mathbb{V}_d$                      & Database variables (attributes) involved in SQL commands  \\
        $v: \mathbb{V} \triangleq \mathbb{V}_d $ & Variables                                                 \\
        $e: \mathbb{E}$                          & Arithmetic expressions                                    \\
        $b: \mathbb{B}$                          & Boolean expressions                                       \\
        $A_{sql}: \mathbb{A}_{sql}$              & Action part of SQL commands                               \\
        $\tau: \mathbb{T}$                       & Terms                                                     \\
        $a_f: \mathbb{A}_f$                      & Atomic formulas                                           \\
        $\phi : \mathbb{W}$                      & Well-formed formulas (pre-condition part of SQL commands) \\
        $C_{sql}: \mathbb{C}_{sql}$              & SQL commands                                              \\
        $I: \mathbb{I}$                          & Instructions/commands                                     \\
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{l l}
        $c ::=$ & $n \mid k$ \\
        $e ::=$ & $c \mid v_d \mid v_a \mid ap_u e \mid e_1 op_b e_2$ , where $op_u$ and $op_b$ represent unary and binary arithmetic operations respectively. \\
        $e ::=$ & $e_1 = e_2 \mid e_1 \geq \mid e_1 \leq e_2 \mid e_1 > e_2 \mid e_1 < e_2 \mid e_1 \neq e_2 \mid \neg b \mid b_1 \lor b_2 \mid b_1 \land b_2 \mid \texttt{true} \mid \texttt{flase}$ \\
        $\tau ::=$ & $c \mid v_a \mid v_d \mid f_n(\tau_1, \tau_2, \dots, \tau_n)$, where $f_n$ is an $n$-any function. \\
        $a_f ::=$ & $R_n(\tau_1, \tau_2, \dots, \tau_n) \mid \tau_1 = \tau2$, where $R_n$ is an $n$-ary relation: $R_n(\tau_1, \tau_2, \dots, \tau_n) \in \{ \texttt{true}, \texttt{false}\}$ \\
        $\phi ::=$ & $a_f \mid \neg \phi_1 \mid \phi_1 \lor \phi_2 \mid \phi_1 \land \phi_2 \mid \forall \textbf{x}_i \phi \mid \exists \textbf{x}_i \phi$ \\
        $g(\overrightarrow{e}) ::=$  & $\texttt{GROUP BY} \overrightarrow{e} \mid id$ \\
        $r ::= $ & $\texttt{DISTINCT} \mid \texttt{ALL}$ \\
        $s ::= $ & $\texttt{AVG} \mid \texttt{SUM} \mid \texttt{MAX} \mid \texttt{MIN} \mid \texttt{COUNT}$ \\
        $h(e) ::= $ & $s \bigcirc r(e) \mid \texttt{DISTINCT}(e) \mid id$ \\
        $h(*) ::= $ & $\texttt{COUNT(*)}$ \\
        $\overrightarrow{h}(\overrightarrow{\textbf{x}}) ::= $ & $\langle h_1(\textbf{x}_1), \dots, h_n(\textbf{x}_n)\rangle$, where $\overrightarrow{h} = \langle \rangle$ \\
        $f(\overrightarrow{e}) ::=$ & $\texttt{ORDER BY ACE}(\overrightarrow{e}) \mid \texttt{ORDER BY DESC}(\overrightarrow{e}) \mid id$ \\
        $A_{sql} :: =$ & $select(v_a, f(\overrightarrow{e'}), r(\overrightarrow{h}(\overrightarrow{\textbf{x}})), \phi, g(\overrightarrow{e})) \mid update(\overrightarrow{v_d}, \overrightarrow{e}) \mid delete(\overrightarrow{v_d})$ \\
        $C_{sql} ::=$ & $\langle A_{sql}, \phi \rangle \mid C_{sql}' \texttt{UNION} C_{sql}'' \mid C_{sql}' \texttt{INTERSECT} C_{sql}'' \mid C_{sql}' \texttt{MINUS} C_{sql}''$ \\
        $I ::=$ & $skip \mid v_a := e \mid v_a := ? \mid C_{sql} \mid$ if $b$ then $I_1$ else $I_2$ $\mid$ while $b$ do $I$ $\mid$ $I_1; I_2$ \\
    \end{tabular}
\end{center}



$s = shortestString(R) =$ A function that analyses a regular expression and returns the shortest string. This is done, by creating an automaton and finding the shortest route to the end state.

$S = longestString(R) =$ A function that analyses a regular expression and returns the longest string. This is done by creating an automaton and finding the longest route to the end state. And returns $\infty$ if a loop is detected.
s and S are representations for the longest and shortest strings.

$length(x) = \mid x \mid $

$position(R1, in, R2) =$ A function that returns the first position of the first possible occurrence of $R1$ in $R2$.
R1 and $R2$ are regular expressions, the function can be defined by traversing $R2$ and check for the first possible occurrence of $R1$. If no occurrence is found, the function returns $0$.

$substring(R, I_1, I_2)$ A function that returns the sub regular expression of $R$ from position $I_1$ to $I_2$.
$R$ is a regular expression and $I_1$ and $I_2$ are integers. The function can be defined by traversing $R$ and returning a list of all possible


$trim(pos, R_1 from R_2) =$ A function that, depending on the position variable, either removes all leading, trailing, or both leading and trailing occurrences of $R_1$ from $R_2$.
$R_1$ and $R_2$ are regular expressions. $pos$ is a string that can be either "leading", "trailing", or "both", "both" is the default.
\[
    \text{trim}(\text{pos}, R_1, R_2) =
    \begin{cases}
        \{ s \mid s \in R_2, s \text{ does not start with } R_1 \}        & \text{if } \text{pos} = \text{"leading"} \text{ or } \text{pos} = \text{"both"}  \\
        \{ s \mid s \in R_2, s \text{ does not end with } R_1 \}          & \text{if } \text{pos} = \text{"trailing"} \text{ or } \text{pos} = \text{"both"} \\
        \{ s \mid s \in R_2, s \text{ does not start or end with } R_1 \} & \text{if } \text{pos} = \text{"both"}                                            \\
    \end{cases}
\]

\todo[inline]{Lars says: Should be make each function defintion an align?}

\subsection{Abstract Semantics}

\begin{align}
    S_1 \aop S_2 &= \{ s_1 \aaop s_2 \mid s_1 \in S_1, s_2 \in S_2 \} \\
    \aop S &= \{\aaop s \mid s \in S \}
\end{align}

\subsubsection{Abstract Semantics of Boolean expressions}

\begin{align}
    B_1 \;\aab{bop}\; B_2 = \bigcup_{b_1 \in B_2, b_2 \in B_2} b_1 \;\aaab{bop}\; b_2
\end{align}

\begin{align}
    \absboolsem{\texttt{true}}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \{\{\true\}\} \\
    \absboolsem{\texttt{false}}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \{\{\false\}\} \\
    \absboolsem{b_1 \lor b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absboolsem{b_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ab{\lor} \absboolsem{b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \absboolsem{b_1 \land b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absboolsem{b_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ab{\land} \absboolsem{b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \absboolsem{\neg b}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{\neg} \absboolsem{b}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \absboolsem{e_1 \neq e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{\neg}(\absexpsem{e_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \;\ab{=}\; \absexpsem{e_2}(\rho_{\ab{d}}, \rho_{\ab{a}})) \\
    \absboolsem{e_1 \;comp\; e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absexpsem{e_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \;\ab{\comp}\; \absexpsem{e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
\end{align}

\begin{table}[H]
    \centering
    \begin{tabular}{c|ccc}
        $\aaab{\lor}$ & $\true$ & $\false$ & $\mnull$ \\
        \hline
        $\true$ & $\{\true\}$ & $\{\false\}$ & $\{\mnull\}$ \\
        $\false$ & $\{\false\}$ & $\{\false\}$ & $\{\false\}$ \\
        $\mnull$ & $\{\mnull\}$ & $\{\false\}$ & $\{\mnull\}$ \\
    \end{tabular}
    \label{tab:aaablor}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{c|ccc}
        $\aaab{\land}$ & $\true$ & $\false$ & $\mnull$ \\
        \hline
        $\true$ & $\{\true\}$ & $\{\true\}$ & $\{\true\}$ \\
        $\false$ & $\{\true\}$ & $\{\false\}$ & $\{\mnull\}$ \\
        $\mnull$ & $\{\true\}$ & $\{\mnull\}$ & $\{\mnull\}$ \\
    \end{tabular}
    \label{tab:aaabland}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{c|ccc}
        $\aaab{\neg}$ & $\true$ & $\false$ & $\mnull$ \\
        \hline
        $\true$ & $\{\false\}$ & $\{\true\}$ & $\{\mnull\}$ \\
    \end{tabular}
    \label{tab:aaabneg}
\end{table}

For regular expressions $R, R_1, R_2$, linear inequalities over one variable $N, N_1, N_2$ and arbitrary values $X$:

\begin{align}
    X_1 \;\aab{=}\; X_2 &= \begin{cases}
        \begin{cases}
        \{\true \} & \text{if } |X_1| = |X_2| = 1 \land X_1 = X_2 \\
        \{\false\} & \text{if } X_1 \cap X_2 = \emptyset \\
        \{\true, \false\} & \text{if } X_1 \cap X_2 \neq \emptyset
        \end{cases} & \text{if $X_1$ and $X_2$ is of the same type} \\
        \text{undefined} & \text{otherwise}
    \end{cases} \\
\end{align}

\begin{align}
    I_1 \;\aab{<}\; I_2 &= \begin{cases}
        \{\true\} & \text{if } \max(X_1) < \min(X_2) \\
        \{\false\} & \text{if } \max(X_2) \leq \min (X_1) \\
        \{\true, \false\} & \text{otherwise}
    \end{cases}
\end{align}

\begin{align}
    I_1 \;\aab{\leq}\; I_2 &= \begin{cases}
        \{\true\} & \text{if } \max(X_1) \leq \min(X_2) \\
        \{\false\} & \text{if } \max(X_2) < \min (X_1) \\
        \{\true, \false\} & \text{otherwise}
    \end{cases}
\end{align}

\subsubsection{Abstract Semantics of Expressions}

\begin{align}
    \absexpsem{n}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \{ \{ [n, n] \} \}\\
    \absexpsem{k}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \{ R \} \text{ such that }\mathcal{L}(R) = \{ k \} \\
    \absexpsem{v_a}(\rho_{\ab{d}}, \rho_{\ab{a}}) &=  \rho_{\ab{a}}(v_a) \\
    \absexpsem{v_d}(\rho_{\ab{d}}, \rho_{\ab{a}}) &=  \rho_{\ab{t}}(v_d) \text{ such that } \ab{t} \in dom(\ab{d}) \text{ and } v_d \in attr(\ab{t}) \\
    \absexpsem{op \; e}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{op} \; (\absexpsem{e}(\rho_{\ab{d}}, \rho_{\ab{a}})) \\
    \absexpsem{e_1 \; op \; e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absexpsem{e}(\rho_{\ab{d}}, \rho_{\ab{a}}) \;\ab{op}\; \absexpsem{e}(\rho_{\ab{d}}, \rho_{\ab{a}})\\
\end{align}

We define the length of a regular expression $R$, $\|R\|$:

\begin{align}
    \|R\| = \begin{cases}
        \{ [\|\min(R)\|, \|\max(R)\|] \} & \text{if $\|\max(R)\|$ is defined} \\
        \{ [\|\min(R)\|, +\infty) \} & \text{if $\|\max(R)\|$ is undefined}
    \end{cases}
\end{align}

\begin{align}
    \|\min(R)\| &= \min\{ \|s\| \mid s \in R \} \\
    \|\max(R)\| &= \max\{ \|s\| \mid s \in R \} \\
    \text{where $\|s\|$ is the length of the word $s$}
\end{align}

\begin{align}
    cvt(op, R_1 \cup R_2) &= cvt(op, R_1) \cup cvt(op, R_2) \\
    cvt(op, R_1 \cap R_2) &= cvt(op, R_1) \cap cvt(op, R_2) \\
    cvt(op, R_1R_2) &= cvt(op, R_1) \; cvt(op, R_2) \\
    cvt(op, R) &= (cvt(op, R))^\star \\
    cvt(op, \overline{R}) &= cvt(op, (\mathcal{R} \circ \mathcal{A}) (\overline{R})) \\
    cvt(op, \sigma) &= op(\sigma)
\end{align}

\begin{align}
    R_1 \;\aab{||}\; R_2 &= R_1R_2 \\
    \aab{lower}(R) &= cvt(\sigma \mapsto \sigma', R) \text{ such that $\sigma'$ is the lowercase representation of $\sigma$}\\
    \aab{upper}(R) &= cvt(\sigma \mapsto \sigma', R) \text{ such that $\sigma'$ is the uppercase representation of $\sigma$}\\
    \aab{bit\_length}(R) &= \|cvt(\sigma \mapsto \sigma', R)\| \text{ such that $\sigma'$ is the bit string of $\sigma$} \\
    \aab{length}(R) &= \|R\|
\end{align}

\begin{align}
    I_1 \;\aab{aop}\; I_2 &= m(\{i_1 \; aop \; i_2 \mid i_1 \in I_1 \land i_2 \in I_2\}) \\
\end{align}

\subsubsection{Abstract Semantics of SQL statements}

Let
\begin{equation}
    \mathcal{C} : \mathbb{V}_a \cup \mathbb{V}_d \rightarrow \{ C_{X_1}(S_1), C_{X_2}(S_2), \dots, C_{X_n}(S_n) \}
\end{equation}

\begin{align}
    \abssqlsem{\langle C_{insert}, \phi \rangle}(\rho_{\ab{d}}, \rho_{\ab{a}}) & =
    \abssqlsem{\langle insert(\mathbf{v}_d, \mathbf{e}), \phi \rangle}(\rho_{\ab{t}}, \rho_{\ab{a}})\\
    & = (\rho_{\ab{t} \sqcup s}, \rho_{\ab{a}}) \\
    \text{where } target(C_{insert})        & = \ab{t}                                                                                                                                                 \\
    \mathbf{v}_d              & = \langle a_1, a_2, \dots, a_n \rangle                                                                                                        \\
                                               & = attr(\ab{t})                                                                                                                                           \\
    \mathbf{e} & = \langle e_1, e_2, \dots, e_n \rangle \\
    s &= \{ (s_1/a_1, s_2/a_2, \dots, s_n/a_n) \mid (s_1, s_2, \dots, s_n) \in \bigtimes_{i = 1}^{n} \left( \absexpsem{e_i}(\rho_{\ab{d}}, \rho_{\ab{a}}) \into \lookupcl(a_i) \right) \}
\end{align}

\begin{align}
    \abssqlsem{C_{update}}(\env{\abstable}, \env{\absvars})
                                              & = \abssqlsem{\langle update(\absattrs, \absexps), \abspred \rangle} (\env{\abstable}, \env{\absvars}) \\
                                              & = (\env{\abstable'}, \env{\absvars})                                                                 \\
    \text{where } \env{\abstable'}(\absattr) & =
    \begin{cases}
        \env{\abstable \downarrow_t \abspred}(\absattr) \sqcup \env{\abstable \downarrow_u \abspred}(\absattr) \sqcup \env{\abstable \downarrow_f \abspred}(\absattr) & \text{if } \absattr \notin \absattrs \\
        \absexpsem{\absexp{i}}(\env{\abstable \downarrow_t \abspred}, \env{\absvars}) \sqcup
        \left( \absexpsem{\absexp{i}}(\env{\abstable \downarrow_u \abspred}, \env{\absvars}) \sqcup \env{\abstable \downarrow_u \abspred}(\absattr) \right) \sqcup \env{\abstable \downarrow_f \abspred}(\absattr) \\
        \text{if $\absattr$ is the $i$th component of $\absattrs$ and $\absexp{i}$ is the $i$th componenet of $\absexps$} \\
    \end{cases}
\end{align}

\begin{align*}
    \abssqlsem{C_{delete}}(\env{\abstable}, \env{\absvars})
    &= \abssqlsem{\langle delete(\absattrs), \abspred \rangle} (\env{\abstable}, \env{\absvars}) \\
    &= (\env{\abstable'}, \env{\absvars}) \\
    \text{where } \env{\abstable'}(\absattr) &= \env{\abstable \downarrow_u \abspred}(\absattr) \sqcup \env{\abstable \downarrow_f \abspred}(\absattr)
\end{align*}

\subsubsection{Abstract Semantics of Actions}

Let $\ab{P}$ be a set of abstract environments $(\env{\abstable}, \env{\absvars})$.

\begin{align}
    \abssem{\texttt{skip}}(\ab{P}) &= \ab{P} \\
    \abssem{v_a := e}(\ab{P}) &= \{(\env{\abstable}, \env{\absvars}[v_a \mapsto s']) \mid (\env{\abstable}, \env{\absvars}) \in \ab{P} \land s = \absexpsem{e}(\env{\abstable}, \env{\absvars}) \land s' = s \into \lookupcl(v_a) \} \\
    \abssem{v_a := \; ?}(\ab{P}) &= \{(\env{\abstable}, \env{\absvars}[v_a \mapsto \top]) \mid (\env{\abstable}, \env{\absvars}) \in \ab{P} \} \\
    \abssem{b}(\ab{P}) &= \{ (\env{\abstable}, \env{\absvars}) \in \ab{P} \mid \true \in B \land B \in \absboolsem{b}(\env{\abstable}, \env{\absvars}) \} \\
    \abssem{C_{sql}}(\ab{P}) &= \{\abssqlsem{C_{sql}}(\env{\abstable}, \env{\absvars}) \mid (\env{\abstable}, \env{\absvars}) \in \ab{P} \}
\end{align}

% \begin{align*}
%     E^\# \llbracket R_1 \texttt{||} R_2 \rrbracket                          \\
%     = E^\# \llbracket R_1 \rrbracket \oplus  E^\# \llbracket R_2 \rrbracket \\
%     \text{where } R_1 \text{ and } R_2 \text{ are regular expressions and } \\
%     \oplus \text{ is the concatenation operator.}
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{bit\_length} (R) \rrbracket \\
%     =  [length(B(s)), length(B(S))]                     \\
%     bit\_length \text{ returns a range of the binary}   \\
%     \text{ representation of regular expression } R.    \\
%     \text{where } B(s) \text{ is the binary representation of }s
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{char\_length} (R) \rrbracket       \\
%     =  [length(s), lenght(S)]                                  \\
%     char\_length \text{ returns a range of the shortest and}   \\
%     \text{ longest string created from the regular expression} \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{lower} (c) \rrbracket =c'                                                    \\
%     E^\# \llbracket \texttt{lower}(R_1 \cup R_2) \rrbracket                                              \\
%     = E^\# \llbracket \texttt{lower}(R_1) \rrbracket \cup E^\# \llbracket \texttt{lower}(R_2) \rrbracket \\
%     E^\# \llbracket \texttt{lower}(R_1 \cap R_2) \rrbracket                                              \\
%     = E^\# \llbracket \texttt{lower}(R_1) \rrbracket \cap E^\# \llbracket \texttt{lower}(R_2) \rrbracket \\
%     E^\# \llbracket \texttt{lower}(R_1^*) \rrbracket                                                     \\
%     = E^\# \llbracket \texttt{lower}(R_1)^* \rrbracket                                                   \\
%     \text{Where }c \in \Sigma \text{ and } c' \text{ is the lower case of } c.                           \\
%     R_1 \text{ and } R_2 \text{ are regular expressions.}                                                \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{upper}(R) \rrbracket \\
%     \text{Where upper is the same as lower but converts to upper case.}
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{position}(R_1, in, R_2) \rrbracket \\
%     = I                                             \\
%     \text{where } R1 \text{ and } R2 \text{ are regular expressions and }
%     I \text{ is an integer.}                        \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{sub\_string} (R, I_1, I_2) \rrbracket \\
%     = []                                                          \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{trim} ('pos', R_1 \text{ from } R_2) \rrbracket                            \\
%     =  \texttt{trim}('pos', R_1 \text{ from } R_2)                                                     \\
%     \texttt{trim} \text{ removes all leading, trailing or both occurrences of } R_2 \text{ from } R_1. \\
%     \text{where } R_1 \text{ and } E_2 \text{ are regular expressions, and 'pos' is a string.}         \\
% \end{align*}
%
% \todo[inline]{Casper says:
%     For the tree definitions above a definition should be give for position, substring and trim.
%     We should be able to implement the abstract semantics by following the semantics above.
% }
%
% \subsection{Abstract Interpretation of belongs}
% To provide a precise definition of the belongs function, envision a lattice composed of partitions of a language. We aim to identify the most precise partition that encompasses a given expression. In essence, we seek to pinpoint which element in the lattice accurately describes the expression's location. Simply stating that it resides somewhere within the entire set would lack practicality.
%
% Partitions within this lattice may overlap, symbolizing intersections of languages. The lattice itself is complete, with the top element representing the entire set of languages, and the bottom element indicating the empty set.
%
% Navigating this lattice involves starting from the top and descending until we reach a point where no partitions cover the expression. At this juncture, we have identified the most precise set of partitions that encompass the expression.
%
% $ belongs(x)=\bigsqcap\{x' \mid x \sqsubseteq x', x' \in X\} $
% Taking an expression $x$, we seek to identify the most precise partition that encompasses it. We do this by finding the greatest lowerbound of all partitions that contain $x$.
% % todo same as above
%
% % \begin{restatable}{lemma}{updatemonotone}
% %     $\abssem{C_{update}^\#}$ is monotone.
% % \end{restatable}
% % \pfsketch{
% %     For $\abstable \sqsubseteq \abstablep$ if $\abssem{C_{update}^\#}$ updates elements in $\abstable$ the same elements must be updated in $\abstablep$, therefore the order is determined by the remaining unchanged elements and therefore order is preserved.
% %     If an element not in $\abstable$ is update is changed in $\abstablep$ order is still preserved as the element is 'swapped' for another.
% % }
