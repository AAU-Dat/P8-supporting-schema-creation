\subsection{Abstract Syntax} \label{subsec:function-definitions}

\begin{center}
    \begin{tabular}{l l}
    $n \in \mathbb{Z}$                          & Integers                                                   \\
    $k \in \mathbb{S}$                                  & Strings                                                    \\
    $c \in \mathbb{C}$                          & Constants                                                 \\
    $v_a \in \mathbb{V}_a$                      & Application variables                                     \\
    $v_d \in \mathbb{V}_d$                      & Database variables (attributes) involved in SQL commands  \\
    $v \in \mathbb{V}$ & Variables                                                 \\
    $e \in \mathbb{E}$                          & Arithmetic expressions                                    \\
    $b \in \mathbb{B}$                          & Boolean expressions                                       \\
    $\tau \in \mathbb{T}$                       & Terms                                                     \\
    $a_f \in \mathbb{A}_f$                      & Atomic formulas                                           \\
    $\phi  \in \mathbb{W}$                      & Well-formed formulas (pre-condition part of SQL commands) \\
    $A_{sql} \in \mathbb{A}_{sql}$              & Action part of SQL commands                               \\
    $C_{sql} \in \mathbb{C}_{sql}$              & SQL commands                                              \\
    $I \in \mathbb{I}$                          & Instructions/commands                                     \\
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{l l}
        $c ::=$ & $n \mid k$ \\
        $v ::=$ & $v_d \mid v_a$ \\
        $e ::=$ & $c \mid v \mid ap_u e \mid e_1 op_b e_2$ , where $op_u$ and $op_b$ represent unary and binary arithmetic operations respectively. \\
        $b ::=$ & $e_1 = e_2 \mid e_1 \geq \mid e_1 \leq e_2 \mid e_1 > e_2 \mid e_1 < e_2 \mid e_1 \neq e_2 \mid \neg b \mid b_1 \lor b_2 \mid b_1 \land b_2 \mid \texttt{true} \mid \texttt{flase}$ \\
        $\tau ::=$ & $c \mid v_a \mid v_d \mid f_n(\tau_1, \tau_2, \dots, \tau_n)$, where $f_n$ is an $n$-any function. \\
        $a_f ::=$ & $R_n(\tau_1, \tau_2, \dots, \tau_n) \mid \tau_1 = \tau2$, where $R_n$ is an $n$-ary relation: $R_n(\tau_1, \tau_2, \dots, \tau_n) \in \{ \texttt{true}, \texttt{false}\}$ \\
        $\phi ::=$ & $a_f \mid \neg \phi_1 \mid \phi_1 \lor \phi_2 \mid \phi_1 \land \phi_2 \mid \forall x_n \phi \mid \exists x_n \phi$ \\
        $A_{sql} :: =$ & $select(v_a) \mid update(v_d, e) \mid delete(v_d) \mid insert(v_d, e)$ \\
        $C_{sql} ::=$ & $\langle A_{sql}, \phi \rangle $ \\
        $I ::=$ & $skip \mid v_a := e \mid v_a := ? \mid C_{sql} $\\
    \end{tabular}
\end{center}


\subsection{Abstract Semantics}\label{subsec:abstract-semantics}
This section will describe to abstract semantics of SQAAL.

\autoref{eq:generalBOP} through \ref{eq:generalUOP}, show how operations unary and binary operators can be lifted to operate on the members of $\mathsf{Val} \; a$.
\begin{align}
    \mathsf{Single} \; s_1 \ap{op} \mathsf{Single} \; s_2 &= \mathsf{Single} \; (s_1 \op s_2) \label{eq:generalBOP} \\
    \mathsf{Single} \; s \ap{op} \mathsf{List} \; S &= \mathsf{List} \; \{ s \op s' \mid s' \in S \} \\
    \mathsf{List} \; S \ap{op} \mathsf{Single} \; s &= \mathsf{List} \; \{ s' \op s \mid s' \in S \}  \\
    \mathsf{List} \; S_1 \ap{op} \mathsf{List} \; S_2 &= \mathsf{List} \; \{ s_1 \op s_2 \mid s_1 \in S_1, s_2 \in S_2 \} \\
    \ap{op} (\mathsf{Single} \; s) &= \mathsf{Single} \; (\op s) \\
    \ap{op} (\mathsf{List} \; S) &= \mathsf{List} \; \{ \op s \mid s \in S \} \label{eq:generalUOP}
\end{align}

We define application of abstract unary operators and binary operators between abstract elements by
\begin{equation}
    \aop = \ap{\aaop}
\end{equation}
, where $\aaop$ is defined for the respective types later on.

Similarly we define:
\begin{align}
    \mathsf{Single} \; s_1 \app{op} \mathsf{Single} \; s_2 &= \mathsf{List} \; (\{s_1\} \op \{s_2\}) \label{eq:generalBOP} \\
    \mathsf{Single} \; s \app{op} \mathsf{List} \; S &= \mathsf{List} \; (\{ s \} \op S) \\
    \mathsf{List} \; S \app{op} \mathsf{Single} \; s &= \mathsf{List} \; (S \op \{ s \})  \\
    \mathsf{List} \; S_1 \app{op} \mathsf{List} \; S_2 &= \mathsf{List} \; (S_1 \op S_2) \\
    \app{op} (\mathsf{Single} \; s) &= \mathsf{List} \; (\op \{ s \}) \\
    \app{op} (\mathsf{List} \; S) &= \mathsf{List} \; (\op S ) \label{eq:generalUOP}
\end{align}
This will also be helpful later.

\subsubsection{Abstract Semantics of Boolean expressions}
We now define the general abstract semantics of boolean expressions.
$\aab{bop}$ is defined to be a special case of $\aaop$ as follows:
\begin{align}
    B_1 \;\aab{bop}\; B_2 = \bigcup_{b_1 \in B_2, b_2 \in B_2} b_1 \;\aaab{bop}\; b_2
\end{align}
Where $\aaab{bop}$ is defined for $\land$, $\lor$ and $\neg$ in \autoref{tab:aaabland}, \autoref{tab:aaablor} and \autoref{tab:aaabneg} respectively.

\autoref{eq:abstract-bool-semantics-start} through \ref{eq:abstract-bool-semantics-end2} show the abstract semantics of boolean expressions, that is logical operators and comparisons between expressions.
Definition \ref{eq:abstract-bool-semantics-start} through \ref{eq:abstract-bool-natural} are fairly natural, definition \ref{eq:abstract-bool-semantics-end2} however requires an explanation.
In the otherwise case, when $e_1$ and $e_2$ do not both evaluate to lists, we proceed as as expected.
In the case where both $e_1$ and $e_2$ both evaluate to list we take into account the fact that there might be more tuples in one or the other, therefore adding $null$ as on of the values that might be present in the result.

\begin{align}
    \absboolsem{\texttt{true}}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \mathsf{Single} \; \{\true\} \label{eq:abstract-bool-semantics-start} \\
    \absboolsem{\texttt{false}}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \mathsf{Single} \; \{\false\} \\
    \absboolsem{b_1 \lor b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absboolsem{b_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ab{\lor} \absboolsem{b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \absboolsem{b_1 \land b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absboolsem{b_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ab{\land} \absboolsem{b_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \absboolsem{\neg b}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{\neg} \absboolsem{b}(\rho_{\ab{d}}, \rho_{\ab{a}}) \label{eq:abstract-bool-natural} \\
    % \absboolsem{e_1 \neq e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{\neg}(\absexpsem{e_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \;\ab{=}\; \absexpsem{e_2}(\rho_{\ab{d}}, \rho_{\ab{a}})) \label{eq:abstract-bool-semantics-end1} \\
    \absboolsem{e_1 \;comp\; e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &=
    \begin{cases}
        \app{\{\{null\}\} \cup} E & \text{if } E_1 = \mathsf{List} \; S_1 \land E_2 = \mathsf{List} \; S_2 \land E_1 \;\ab{\comp}\; E_2 = E\\
        E_1 \;\ab{\comp}\; E_2 & \text{otherwise}\\
    \end{cases}\label{eq:abstract-bool-semantics-end2} \\
    \text{where } & E_1 = \absexpsem{e_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \text{and } & E_2 = \absexpsem{e_2}(\rho_{\ab{d}}, \rho_{\ab{a}})
\end{align}

\begin{table}[H]
    \centering
    \caption{test}
    \begin{tabular}{c|ccc}
        $\aaab{\land}$ & $\true$ & $\false$ & $\mnull$ \\
        \hline
        $\true$ & $\{\true\}$ & $\{\false\}$ & $\{\mnull\}$ \\
        $\false$ & $\{\false\}$ & $\{\false\}$ & $\{\false\}$ \\
        $\mnull$ & $\{\mnull\}$ & $\{\false\}$ & $\{\mnull\}$ \\
    \end{tabular}
    \label{tab:aaabland}
\end{table}

\begin{table}[H]
    \centering
    \caption{test}
    \begin{tabular}{c|ccc}
        $\aaab{\lor}$ & $\true$ & $\false$ & $\mnull$ \\
        \hline
        $\true$ & $\{\true\}$ & $\{\true\}$ & $\{\true\}$ \\
        $\false$ & $\{\true\}$ & $\{\false\}$ & $\{\mnull\}$ \\
        $\mnull$ & $\{\true\}$ & $\{\mnull\}$ & $\{\mnull\}$ \\
    \end{tabular}
    \label{tab:aaablor}
\end{table}

\begin{table}[H]
    \centering
    \caption{test}
    \begin{tabular}{c|ccc}
        $\aaab{\neg}$ & $\true$ & $\false$ & $\mnull$ \\
        \hline
        $\true$ & $\{\false\}$ & $\{\true\}$ & $\{\mnull\}$ \\
    \end{tabular}
    \label{tab:aaabneg}
\end{table}


For abstract integers (union of intervals) $\mathscr{I}_1$ and $\mathscr{I}_2$ and arbitrary values $X_1$ and $X_2$ (either intervals or regular expressions) we define their abstract comparison in \autoref{eq:aaabcomp} through \ref{eq:aaabcomp3}.
For abstract equality (\autoref{eq:aaabcomp}) we required that the two abstract values being compared are of the same type, either both are abstract integers or both are abstract strings lest the result is undefined.
If the two abstract values only represent the same one value, equality can obviously only be true.
In the case that values the two abstract values represent don't intersect, equality can only be false.
Otherwise they overlap, and which case we are unsure whether the concrete values that can be derived are equal.
\begin{align} \label{eq:aaabcomp}
    X_1 \;\aab{=}\; X_2 &= \begin{cases}
        \begin{cases}
        \{\true\} & \text{if } |X_1| = |X_2| = 1 \land X_1 = X_2 \\
        \{\false\} & \text{if } X_1 \cap X_2 = \emptyset \\
        \{\true, \false\} & \text{otherwise }
        \end{cases} & \text{if $X_1$ and $X_2$ is of the same type} \\
        \text{undefined} & \text{otherwise}
    \end{cases}
\end{align}
$min(\mathscr{I})$ and $max(\mathscr{I})$ denotes the maximum and minimum value represented by $\mathscr{I}$, we argue that such values can easily be computed if $\mathscr{I}$ is kept in a canonical form within the actual implementation.
With the former mentioned, \autoref{eq:aaabcomp2} and \ref{eq:aaabcomp3} should be self explanatory.
To further clarify we only allow abstract integers to be compared in this way.
\begin{align}\label{eq:aaabcomp2}
    \mathscr{I}_1 \;\aab{<}\; \mathscr{I}_2 &= \begin{cases}
        \{\true\} & \text{if } \max(\mathscr{I}_1) < \min(\mathscr{I}_2) \\
        \{\false\} & \text{if } \max(\mathscr{I}_2) \leq \min (\mathscr{I}_1) \\
        \{\true, \false\} & \text{otherwise}
    \end{cases}
\end{align}
\begin{align}\label{eq:aaabcomp3}
    \mathscr{I}_1 \;\aab{\leq}\; \mathscr{I}_2 &= \begin{cases}
        \{\true\} & \text{if } \max(\mathscr{I}_1) \leq \min(\mathscr{I}_2) \\
        \{\false\} & \text{if } \max(\mathscr{I}_2) < \min (\mathscr{I}_1) \\
        \{\true, \false\} & \text{otherwise}
    \end{cases}
\end{align}

\subsubsection{Abstract Semantics of Expressions}

Here we define the abstract semantics of expressions in SQAAL.

\autoref{sem:exp1} to \ref{sem:exp2} describe the semantics of constants.
In \autoref{sem:exp3} to \ref{sem:exp4} we describe the semantics of variables.
In the case of database variables in \autoref{sem:exp4}, we assume attribute names do not clash.
\autoref{eq:exp-lookup} and \autoref{eq:unary-op} describe the semantics of unary and binary operations on expressions.

\begin{align}\label{sem:exp1}
    \absexpsem{n}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \mathsf{Single} \; \{ [n, n] \} \\\label{sem:exp2}
    \absexpsem{k}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \mathsf{Single} \; R,  \text{ such that }\mathcal{L}(R) = \{ k \} \\ \label{sem:exp3}
    \absexpsem{v_a}(\rho_{\ab{d}}, \rho_{\ab{a}}) &=  \rho_{\ab{a}}(v_a) \\ \label{sem:exp4}
    \absexpsem{v_d}(\rho_{\ab{d}}, \rho_{\ab{a}}) &=  \mathsf{List} \; \rho_{\ab{t}}(v_d) \text{ such that } \ab{t} \in dom(\ab{d}) \text{ and } v_d \in attr(\ab{t}) \\ \label{eq:exp-lookup}
    \absexpsem{op \; e}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{op} \; (\absexpsem{e}(\rho_{\ab{d}}, \rho_{\ab{a}})) \\ \label{eq:unary-op}
    \absexpsem{e_1 \;op\; e_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &=
    \begin{cases}
        \mathsf{List} \; \left(S' \cup \{\{null\}\} \right) & \text{if } E_1 = \mathsf{List} \; S_1 \land E_2 = \mathsf{List} \; S_2 \land E_1 \;\ab{op}\; E_2 = \mathsf{List} \; S'\\
        E_1 \;\ab{op}\; E_2 & \text{otherwise}\\
    \end{cases} \\
    \text{where } & E_1 = \absexpsem{e_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \text{and } & E_2 = \absexpsem{e_2}(\rho_{\ab{d}}, \rho_{\ab{a}})
\end{align}

Before defining the abstract operations, $\aaop$, for expressions, we will define some auxiliary functions.
We define the length of a regular expression $R$, $\|R\|$:
\begin{align}\label{eq:r1}
    \|R\| & = \{ \left[ \|\min(R)\|, +\infty \right) \} \\
    \text{where } & \|\min(R)\| = \min\{ \|s\| \mid s \in R \} \\ \label{eq:r2}
    \text{and } & \|s\| \text{ is the length of the word $s$}
\end{align}

We can find $\min(R)$ in \autoref{eq:r1} from the initial state to any final state by the shortest path algorithm.

Next, we define $cvt$, which is String conversion generalized to regular expressions, defined by recursing on the operands of union, intersection, concatenation and Kleene star.
In the base case, a single symbol is converted as defined by $op$.
In the case of the complement, seen in \autoref{eq:complement}, we convert $\overline{R}$ to its DFA equivalent by the usual construction, $\mathcal{A}:REG\rightarrow DFA$, as shown in~\cite{sipserbook}.
This automaton is then converted back to a regular expression by the usual GNFA construction, $\mathcal{R}: DFA\rightarrow REG$, thus eliminating the complement. \todo{reference to Sipser}

\begin{align}
    cvt(op, R_1 \cup R_2) &= cvt(op, R_1) \cup cvt(op, R_2) \\
    cvt(op, R_1 \cap R_2) &= cvt(op, R_1) \cap cvt(op, R_2) \\
    cvt(op, R_1R_2) &= cvt(op, R_1) \; cvt(op, R_2) \\
    cvt(op, R^\star) &= (cvt(op, R))^\star \\
    cvt(op, \overline{R}) &= cvt(op, (\mathcal{R} \circ \mathcal{A}) (\overline{R})) \\ \label{eq:complement}
    cvt(op, \sigma) &= op(\sigma)
\end{align}

\autoref{eq:concat} to \ref{eq:length} describe a subset of String operators present in PostgreSQL.

\begin{align}\label{eq:concat}
    R_1 \;\aab{||}\; R_2 &= R_1R_2 \\
    \aab{lower}(R) &= cvt(\sigma \mapsto \sigma', R) \text{ such that $\sigma'$ is the lowercase representation of $\sigma$}\\
    \aab{upper}(R) &= cvt(\sigma \mapsto \sigma', R) \text{ such that $\sigma'$ is the uppercase representation of $\sigma$}\\
    \aab{bit\_length}(R) &= \|cvt(\sigma \mapsto \sigma', R)\| \text{ such that $\sigma'$ is the bit string of $\sigma$} \\ \label{eq:length}
    \aab{length}(R) &= \|R\|
\end{align}

\autoref{eq:abstractBOP} describes how to do binary operations on numbers.
The arithmetic operations, $aop$, are defined as the standard for intervals.

\begin{align}
    I_1 \;\aab{aop}\; I_2 &= m(\{i_1 \; aop \; i_2 \mid i_1 \in I_1 \land i_2 \in I_2\})  \label{eq:abstractBOP}
\end{align}

\subsubsection{Abstract Semantics of Predicates}
The base rule of all the predicates is defined in \autoref{eq:atomicformulas}, as this is the base case for all the other predicates.
It takes atomic formulas, $a_f$, of the form corresponding to \autoref{eq:abstract-bool-semantics-end1} and \ref{eq:abstract-bool-semantics-end2}, and returns the boolean value of $a_f$.
The other predicates all build on this base case with rules such as negation, disjunction and conjunction.
\begin{align}\label{eq:atomicformulas}
    \abspredsem{a_f}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \absboolsem{a_f}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \abspredsem{\neg \phi}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \ab{\neg} \left( \abspredsem{\phi}(\rho_{\ab{d}}, \rho_{\ab{a}}) \right) \\
    \abspredsem{\phi_1 \lor \phi_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \abspredsem{\phi_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ab{\lor} \abspredsem{\phi_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \abspredsem{\phi_1 \land \phi_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \abspredsem{\phi_1}(\rho_{\ab{d}}, \rho_{\ab{a}}) \ab{\land} \abspredsem{\phi_2}(\rho_{\ab{d}}, \rho_{\ab{a}}) \\
    \abspredsem{\exists v_n \; \phi}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \underset{s \in \absexpsem{x}}{\ab{\bigvee}} \abspredsem{\phi[s/v_n]} \\
    \abspredsem{\forall v_n \; \phi}(\rho_{\ab{d}}, \rho_{\ab{a}}) &= \underset{s \in \absexpsem{x}}{\ab{\bigwedge}} \abspredsem{\phi[s/v_n]}
\end{align}

\subsubsection{Abstract Semantics of SQL statements}

Let
\begin{equation}
    \mathcal{C} : \mathbb{V} \rightarrow \{ C_{X_1}(S_1), C_{X_2}(S_2), \dots, C_{X_n}(S_n) \}
\end{equation}
where $X_1,...,X_n$ are defined as in \autoref{def:coverlattice} and are provided by the user.
Also $S_1,...,S_n$ are given by the type of $v_a$ and $v_d$.

Let
\begin{align}
    \abstable \downarrow_{\true} \phi &= \{ l \in \ab{t} \mid \mathsf{Single} \; \{ \true \} = \abspredsem{\phi[(\mathsf{Single} \; (\pi_{\mathbf{v}_d}(l)))/\mathbf{v}_d]} \text{ for } \mathbf{v}_d = var_{\ab{t}}(\phi) \} \\
    \abstable \downarrow_{\false} \phi &= \{ l \in \ab{t} \mid \mathsf{Single} \; \{ \false \} = \abspredsem{\phi[(\mathsf{Single} \; (\pi_{\mathbf{v}_d}(l)))/\mathbf{v}_d]} \text{ for } \mathbf{v}_d = var_{\ab{t}}(\phi) \} \\
    \abstable \downarrow_{\unknown} \phi &= \{ l \in \ab{t} \mid \true \in b \in B = \abspredsem{\phi[(\mathsf{Single} \; (\pi_{\mathbf{v}_d}(l)))/\mathbf{v}_d]} \text{ for } \mathbf{v}_d = var_{\ab{t}}(\phi) \} \setminus \abstable \downarrow_{\true} \phi
\end{align}

\begin{align}
    \abssqlsem{\langle select(v_a, \mathbf{v}_d), \phi \rangle}(\rho_{\ab{d}}, \rho_{\ab{a}})
    &= (\rho_{\ab{d}}, \rho_{\ab{a}}[v_a \mapsto \mathsf{List} \left( \pi_{\mathbf{v}_d} \left(\abstable \downarrow_{\true} \phi \cup \abstable \downarrow_{\unknown} \phi \right) \right) \into \lookupcl(v_a) ])
\end{align}

\begin{align}
    \abssqlsem{\langle C_{insert}, \phi \rangle}(\rho_{\ab{d}}, \rho_{\ab{a}}) & =
    \abssqlsem{\langle insert(\mathbf{v}_d, \mathbf{e}), \phi \rangle}(\rho_{\ab{t}}, \rho_{\ab{a}})\\
    & = (\rho_{\ab{t} \cup s}, \rho_{\ab{a}}) \\
    \text{where }& s = \bigtimes_{i = 0}^{n} unwrap\left( \absexpsem{e_i}(\rho_{\ab{d}}, \rho_{\ab{a}}) \right) \into \lookupcl(v_i) \\
    \text{and }& target(C_{insert}) = \ab{t}
\end{align}

\begin{align}
    unwrap &: \mathsf{Val} \; a  \rightarrow \mathcal{P}(a) \\
    unwrap &\;(\mathsf{Single} \; x) = \{x\} \\
    unwrap &\;(\mathsf{List} \; x) = x
\end{align}


\begin{align}
    \abssqlsem{C_{update}}(\env{\abstable}, \env{\absvars})
                                              & = \abssqlsem{\langle update(\absattrs, \absexps), \abspred \rangle} (\env{\abstable}, \env{\absvars}) \\
                                              & = (\env{\ab{t}'}, \env{\absvars})
\end{align}

\begin{align}
    \text{where } \abstable' = \ab{t} \downarrow_{\false} \phi
    & \cup \left\{ l\left[ \mathbf{v}_d \mapsto \pi_{\mathbf{v}_d}(s) \sqcup \pi_{\mathbf{v}_d}(l) \right] \;\middle|\; l \in \ab{t} \downarrow_{\unknown} \phi \land s \in \bigtimes_{i = 0}^{n} unwrap\left( \absexpsem{e_i}(\rho_{\ab{d}}, \rho_{\ab{a}}) \right) \into \lookupcl(v_i)\right\} \\
    & \cup \left\{ l\left[ \mathbf{v}_d \mapsto \pi_{\mathbf{v}_d}(s) \right] \;\middle|\; l \in \ab{t} \downarrow_{\true} \phi \land s \in \bigtimes_{i = 0}^{n} unwrap\left( \absexpsem{e_i}(\rho_{\ab{d}}, \rho_{\ab{a}}) \right) \into \lookupcl(v_i)\right\} \\
\end{align}

\begin{align*}
    \abssqlsem{C_{delete}}(\env{\abstable}, \env{\absvars})
    &= \abssqlsem{\langle delete(\absattrs), \abspred \rangle} (\env{\abstable}, \env{\absvars}) \\
    &= (\env{\abstable'}, \env{\absvars}) \\
    \text{where } \abstable' &= \abstable \downarrow_{\unknown} \phi \cup \abstable \downarrow_{\false} \phi
\end{align*}

\subsubsection{Abstract Semantics of Actions}
This section will cover the abstract semantics of actions in SQAAL.
In general, the abstract semantics of actions are defined as a function that takes a set of abstract environments and returns an updated set of abstract environments.
This means that when an action is taken, the abstract environment is updated to reflect the changes made by the action.
An example of this could be with the skip action, where the abstract environment is not changed.


Let $\ab{P}$ be a set of abstract environments $(\env{\abstable}, \env{\absvars})$.

\begin{align}
    \abssem{\texttt{skip}}(\ab{P}) &= \ab{P} \\
    \abssem{v_a := e}(\ab{P}) &= \{(\env{\abstable}, \env{\absvars}[v_a \mapsto s']) \mid (\env{\abstable}, \env{\absvars}) \in \ab{P} \land s = \absexpsem{e}(\env{\abstable}, \env{\absvars}) \land s' = s \into \lookupcl(v_a) \} \\
    \abssem{v_a := \; ?}(\ab{P}) &= \{(\env{\abstable}, \env{\absvars}[v_a \mapsto \mathsf{Single} \; \top]) \mid (\env{\abstable}, \env{\absvars}) \in \ab{P} \} \\
    \abssem{b}(\ab{P}) &= \{ (\env{\abstable}, \env{\absvars}) \in \ab{P} \mid \true \in B \land B \in \absboolsem{b}(\env{\abstable}, \env{\absvars}) \} \\
    \abssem{C_{sql}}(\ab{P}) &= \{\abssqlsem{C_{sql}}(\env{\abstable}, \env{\absvars}) \mid (\env{\abstable}, \env{\absvars}) \in \ab{P} \}
\end{align}

\begin{restatable}{theorem}{csql}\label{thm:csql}
    $\abssem{I}$ is a monotone function in a complete lattice.
\end{restatable}

% \begin{align*}
%     E^\# \llbracket R_1 \texttt{||} R_2 \rrbracket                          \\
%     = E^\# \llbracket R_1 \rrbracket \oplus  E^\# \llbracket R_2 \rrbracket \\
%     \text{where } R_1 \text{ and } R_2 \text{ are regular expressions and } \\
%     \oplus \text{ is the concatenation operator.}
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{bit\_length} (R) \rrbracket \\
%     =  [length(B(s)), length(B(S))]                     \\
%     bit\_length \text{ returns a range of the binary}   \\
%     \text{ representation of regular expression } R.    \\
%     \text{where } B(s) \text{ is the binary representation of }s
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{char\_length} (R) \rrbracket       \\
%     =  [length(s), lenght(S)]                                  \\
%     char\_length \text{ returns a range of the shortest and}   \\
%     \text{ longest string created from the regular expression} \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{lower} (c) \rrbracket =c'                                                    \\
%     E^\# \llbracket \texttt{lower}(R_1 \cup R_2) \rrbracket                                              \\
%     = E^\# \llbracket \texttt{lower}(R_1) \rrbracket \cup E^\# \llbracket \texttt{lower}(R_2) \rrbracket \\
%     E^\# \llbracket \texttt{lower}(R_1 \cap R_2) \rrbracket                                              \\
%     = E^\# \llbracket \texttt{lower}(R_1) \rrbracket \cap E^\# \llbracket \texttt{lower}(R_2) \rrbracket \\
%     E^\# \llbracket \texttt{lower}(R_1^*) \rrbracket                                                     \\
%     = E^\# \llbracket \texttt{lower}(R_1)^* \rrbracket                                                   \\
%     \text{Where }c \in \Sigma \text{ and } c' \text{ is the lower case of } c.                           \\
%     R_1 \text{ and } R_2 \text{ are regular expressions.}                                                \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{upper}(R) \rrbracket \\
%     \text{Where upper is the same as lower but converts to upper case.}
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{position}(R_1, in, R_2) \rrbracket \\
%     = I                                             \\
%     \text{where } R1 \text{ and } R2 \text{ are regular expressions and }
%     I \text{ is an integer.}                        \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{sub\_string} (R, I_1, I_2) \rrbracket \\
%     = []                                                          \\
% \end{align*}
%
% \begin{align*}
%     E^\# \llbracket \texttt{trim} ('pos', R_1 \text{ from } R_2) \rrbracket                            \\
%     =  \texttt{trim}('pos', R_1 \text{ from } R_2)                                                     \\
%     \texttt{trim} \text{ removes all leading, trailing or both occurrences of } R_2 \text{ from } R_1. \\
%     \text{where } R_1 \text{ and } E_2 \text{ are regular expressions, and 'pos' is a string.}         \\
% \end{align*}
%
% \todo[inline]{Casper says:
%     For the tree definitions above a definition should be give for position, substring and trim.
%     We should be able to implement the abstract semantics by following the semantics above.
% }
%
% \subsection{Abstract Interpretation of belongs}
% To provide a precise definition of the belongs function, envision a lattice composed of partitions of a language. We aim to identify the most precise partition that encompasses a given expression. In essence, we seek to pinpoint which element in the lattice accurately describes the expression's location. Simply stating that it resides somewhere within the entire set would lack practicality.
%
% Partitions within this lattice may overlap, symbolizing intersections of languages. The lattice itself is complete, with the top element representing the entire set of languages, and the bottom element indicating the empty set.
%
% Navigating this lattice involves starting from the top and descending until we reach a point where no partitions cover the expression. At this juncture, we have identified the most precise set of partitions that encompass the expression.
%
% $ belongs(x)=\bigsqcap\{x' \mid x \sqsubseteq x', x' \in X\} $
% Taking an expression $x$, we seek to identify the most precise partition that encompasses it. We do this by finding the greatest lowerbound of all partitions that contain $x$.
% % todo same as above
%
% % \begin{restatable}{lemma}{updatemonotone}
% %     $\abssem{C_{update}^\#}$ is monotone.
% % \end{restatable}
% % \pfsketch{
% %     For $\abstable \sqsubseteq \abstablep$ if $\abssem{C_{update}^\#}$ updates elements in $\abstable$ the same elements must be updated in $\abstablep$, therefore the order is determined by the remaining unchanged elements and therefore order is preserved.
% %     If an element not in $\abstable$ is update is changed in $\abstablep$ order is still preserved as the element is 'swapped' for another.
% % }
