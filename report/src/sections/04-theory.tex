\section{theory}\label{sec:theory}
In this section we will present the main contribution of the paper:
First we present the abstract syntax of the programs that the analysis is defined for, further we define the conversion from program to program graph and give the abstract syntax for instructions appearing on the edges within such graphs.
Next we formalize the abstract semantics, and thereafter we argue, through several proof sketches, that the abstract semantics are sound.
At last we prove that our analysis will always terminate.

\input{sections/04-theory/01-abstract-syntax}
\input{sections/04-theory/01-abstract-domains}
\input{sections/04-theory/02-abstract-semantics}
\input{sections/04-theory/05-soundness}
\input{sections/04-theory/06-termination}
\begin{align}\label{eq:exaple equation}
    \begin{split}
    A(q_\whitepointerright)=A(q_\whitepointerright) &\cup \hat E_\whitepointerright \\&\cup \mathcal{\hat S} \lBrack skip \rBrack(A(q_{t4}))\\&\cup \mathcal{\hat S} \lBrack I_{12} \rBrack (A(q_{t6})) \\&\cup \mathcal{\hat S} \lBrack I_3 \rBrack (A(q_i)) \\&\cup \mathcal{\hat S} \lBrack I_5 \rBrack (A(q_d))
    \end{split}\\
    A(q_i)=A(q_i)&\cup \mathcal{\hat S} \lBrack I_1;I_2 \rBrack (A(q_\whitepointerright ))\\
    A(q_d)=A(q_d)&\cup \mathcal{\hat S} \lBrack I_4 \rBrack (A(q_\whitepointerright ))\\
    A(q_{t1})=A(q_{t1})&\cup \mathcal{\hat S} \lBrack I_6;I_7;I_8 \rBrack (A(q_\whitepointerright))\\
    A(q_{t2})=A(q_{t2})&\cup \mathcal{\hat S} \lBrack I_9 \rBrack (A(q_{t1}))\\
    A(q_{t3})=A(q_{t3})&\cup \mathcal{\hat S} \lBrack I_{10} \rBrack (A(q_{t2}))\\
    A(q_{t4})=A(q_{t4})&\cup \mathcal{\hat S} \lBrack b \rBrack (A(q_{t3}))\\
    A(q_{t5})=A(q_{t5})&\cup \mathcal{\hat S} \lBrack \neg b \rBrack (A(q_{t3}))\\
    A(q_{t6})=A(q_{t6})&\cup \mathcal{\hat S} \lBrack I_{11} \rBrack (A(q_{t5}))\\
    A(q_\blackpointerleft)=A(q_\blackpointerleft)
\end{align}