\section{Introduction}\label{sec:introduction}
\IEEEPARstart{S}{oftware} analysis is a broad field encompassing a wide range of techniques and methodologies, each tailored to address specific aspects of software systems.
One such technique is value analysis, which focuses on the behavior of a program with respect to its input and output values~\cite{jackson_software_2000}.
Value analysis can be approached from various angles, including the consideration of meta-information like information flow or taint analysis.
While these approaches offer valuable insights into the behavior of a program, they often require detailed knowledge of the program's internal workings and are not always applicable to all types of software systems.
In this paper we use static program analysis, specifically abstract interpretation.

Abstract interpretation, first proposed by Cousot and Cousot in 1977~\cite{cousot_abstract_1977}, has emerged as a fundamental method for static program analysis.
Over the years, it has evolved into a versatile tool, finding applications across various programming paradigms and system architectures.
Its utility extends beyond traditional imperative programming to encompass object-oriented designs and concurrent systems~\cite{gustafsson_analyzing_2013, mine_static_2023}.
Abstract interpretation has played a pivotal role in analyzing a spectrum of program properties, from basic safety and liveness concerns to intricate security considerations~\cite{mastroeni_abstract_2011}.

Building upon this, Halder and Cortesi have expanded the application of abstract interpretation to domains like query languages~\cite{halder_abstract_2012}.
This paper continues in these footsteps, aiming to further explore and extend the capabilities of abstract interpretation within the context of query languages.


\subsection{Non-terminating Analysis}\label{subsec:non-terminating-analysis}
One problem with Halder and Cortesi is that the analysis they propose may not terminate.
To illustrate, consider the database schema \autoref{lst:motivate-sql} with the program in \autoref{lst:motivate-program}


\begin{listing}
    \begin{minted}{sql}
        CREATE TABLE account (
            name    TEXT,
            balance INT
        );
    \end{minted}
    \caption{A simple schema representing an account.}
    \label{lst:motivate-sql}
\end{listing}


\begin{listing}
    \begin{minted}{bash}
        while true do
            insert((name, balance), ("name", 1))
    \end{minted}
    \caption{A tiny program with nonterminating analysis.}
    \label{lst:motivate-program}
\end{listing}


Because the database context would continually change under Cortesi and Halder, the analysis would not terminate.
However, this doesn't have to be the case.
Extending the analysis to consider abstract tuples, not just abstract values, it is possible to have the analysis terminate for the program in \autoref{lst:motivate-program}.

\todo{\textbf{TODO:Show the contributions through a second example that runs through how we used the updated semantics. Move from method}
}

\subsection{Contributions}\label{subsec:contributions}
\todo[inline]{Casper says: These section (\ref{subsec:contributions}, \ref{subsec:related-work}, \ref{subsec:article-overview}) read like notes, I assume they are.}

%Use Halder concretely for abstract interpretation:
This paper builds on the work of abstract interpretation of database queries by Cortesi and Halder.
Concretely, we use their work to analyze a database schema concerning a program using an alteration of the syntax they describe.

%Improve on the levels of abstraction, i.e., add not just abstract values but also abstract tuples:

Also, by building upon their work, we extend the level of abstraction used in the analysis.
Where they only abstracted over values, this paper also abstracts over tuples in the database, ultimately guaranteeing a finite analysis.
This is thoroughly covered in \autoref{sec:theory}.

%Describe an implementable algorithm for performing static analysis targeting specific properties, given a program and database:

Also included in the contribution is an implementable algorithm, which can be used for performing static analysis.
This algorithm targets specific properties when given a program and its associated database.
The allowed properties can be seen in the following \autoref{subsubsec:properties}.

%Prove soundness for the analysis:
To ensure that our abstractions are correct, we informally prove their soundness.
By doing this, we can always be sure that our abstractions are an overestimation of the concrete values and tuples.
This ensures that an abstract value always represents a concrete value.
The soundness proof can be found in \autoref{subsec:soundness}.

%Describe the properties we wish to check using LTL-like encodings, i.e., phrases like \emph{always, eventually,} and \emph{never}, to describe undesirable database states.\todo{Casper says: As of now we are only able to check invariants.}
\subsubsection{Properties} \label{subsubsec:properties}
While we have not provided a specific method for checking general properties, we have outlined a systematic approach for verifying invariants.
Invariants are a particular type of property that should always be held during the program's execution.

This way, we can check at each step of the program to see if the invariant holds, and if it does not, we can stop the analysis and report that the program is incorrect.

We can check for invariants in every state of the program.
We do this in the program graph, where each node represents a state of the program.
We can check if the invariant holds in each node.
This way, we can systematically verify the program's correctness throughout its execution.

Describing an invariant is done using $\forall$, $\exists$, $\land$, $\lor$, and $\neg$.

An example of an invariant is:
\begin{equation}
    \forall x \in \mathbb{N} : x \geq 0
\end{equation}

This invariant states that for all $x$ in the set of natural numbers $\mathbb{N}$, $x$ must be greater than or equal to 0.
The invariant must hold in every state of the program where x is considered.


\subsection{Related Work}\label{subsec:related-work}

\todo[inline]{Casper says: The seminal work of \cite{cousot_abstract_1977} should also be mentioned here.}

\todo[inline]{Casper says: \cite{cousot_abstract_1996} should also be mentioned here, and maybe the fact that we try to \emph{implement} some of the ideas mentioned namely regular expressions as abstract domains and kindof linear inequalities and in that regard we should mention \cite{li2010abstract}.}

This paper builds on work of abstract interpretation of database queries by Cortesi and Halder~\cite{halder_abstract_2012}.
Concretely, we use their work for analysing a database schema in relation to a program using the syntax they describe.\todo[inline]{Casper says: the Related Works section should also give  brief outline of their contribution.}


Jana et al.~\cite{jana_extending_2020} have extended the application of abstract interpretation to the domain of web security.
Dependency information (data- and/or control-dependencies) among program variables and program statements is playing crucial roles in a wide range of software-engineering activities, e.g., program slicing, information flow security analysis, debugging, code optimization, code reuse, code understanding.
Most existing dependency analyzers focus on mainstream languages, and they do not support database applications embedding queries and data-manipulation commands.
This paper extends the Abstract Interpretation framework for static dependency analysis of database applications, providing a semantics-based computation tunable with respect to precision.

Kashyap et al.~\cite{kashyap_integrity_2022} have proposed a new approach to integrity checking of database applications using abstract interpretation.
The approach is based on the use of abstract interpretation to analyze the database application and to check the integrity of the data, i.e., to verify that the data is consistent with the constraints defined in the database management system.

We use this database-program description together with Linear Temporal Logic (LTL) for describing temporal properties that is interesting with respect to the evolution of the database over time.\todo{Casper says: same as above.}

\subsection{Article Overview}\label{subsec:article-overview}

The rest of the article is structured as follows:
In \autoref{sec:preliminaries} we cover the preliminaries needed to understand the rest of the paper, in particular we cover lattices, program graphs and their semantics and abstract interpretation.
In \autoref{sec:theory} we describe our contribution in detail:
\begin{itemize}
    \item In \autoref{subsec:abstract-syntax} we describe the syntax of the language we of the analysis, further we define the conversion of programs in this language to program graphs;
    \item in \autoref{subsec:abstract-domains} we describe the abstract domains of our analysis and how they related to the concrete domains, notably we describe:
    \begin{itemize}
        \item Regular expressions as an abstract domain for strings,
        \item union intervals as an abstract domain for numbers,
        \item cover-lattices as a technique to deal with infinite lattices in a finite manner,
        \item Abstract bags of abstract tuples as an abstract domain of bags.
    \end{itemize}
    \item In \autoref{subsec:abstract-semantics} we give the abstract semantics for the instructions pertaining to the edges of program graphs, of note we define the abstract semantics for the SQL select-, insert-, update- and delete statement;
    \item In \autoref{subsec:soundness} we argue that our analysis is sound;
    \item and finally in \autoref{} we show that our analysis will terminate.
\end{itemize}
In \autoref{sec:discussion} we discuss the quality of the presented analysis and in \autoref{sec:future-works} we present new avenues for future work.
Finally the we conclude the paper in \autoref{sec:conclusion}.



