\section{Introduction}\label{sec:introduction}
Abstract interpretation, first proposed by Cousot and Cousot in 1977~\cite{cousot_abstract_1977}, has emerged as a fundamental method for static program analysis.
Over the years, it has evolved into a versatile tool, finding applications across various programming paradigms and system architectures.
Its utility extends beyond traditional imperative programming to encompass object-oriented designs and concurrent systems~\cite{gustafsson_analyzing_2013, mine_static_2023}.
Abstract interpretation has played a pivotal role in analyzing a spectrum of program properties, from basic safety and liveness concerns to intricate security considerations~\cite{mastroeni_abstract_2011}.

Building upon this, Halder and Cortesi have expanded the application of abstract interpretation to domains like query languages~\cite{halder_abstract_2012}.
This paper continues in these footsteps, aiming to further explore and extend the capabilities of abstract interpretation within the context of query languages.

Software analysis is a broad field encompassing a wide range of techniques and methodologies, each tailored to address specific aspects of software systems.
One such technique is value analysis, which focuses on the behavior of a program with respect to its input and output values~\cite{jackson_software_2000}.
Value analysis can be approached from various angles, including the consideration of meta-information like information flow or taint analysis.
While these approaches offer valuable insights into the behavior of a program, they often require detailed knowledge of the program's internal workings and are not always applicable to all types of software systems.


\subsection{Example}\label{subsec:example}
One problem with Halder and Cortesi is that the analysis they propose may not terminate.
To illustrate, consider the database schema \autoref{lst:motivate-sql} with the program in \autoref{lst:motivate-program}


\begin{listing}
    \begin{minted}{sql}
        CREATE TABLE account (
            name    TEXT,
            balance INT
        );
    \end{minted}
    \caption{A simple schema representing an account.}
    \label{lst:motivate-sql}
\end{listing}


\begin{listing}
    \begin{minted}{bash}
        while true do
            insert(account, (name, balance), ("name", 1))
    \end{minted}
    \caption{A tiny program with nonterminating analysis.}
    \label{lst:motivate-program}
\end{listing}


Because the database context would continually change under Cortesi and Halder, the analysis would not terminate.
However, this doesn't have to be the case.
Extending the analysis to consider abstract tuples, not just abstract values, it is possible to have the analysis terminate for the program in \autoref{lst:motivate-program}.

Show the contributions through a second example that runs through how we used the updated semantics.

\subsection{Contributions}\label{subsec:contributions}

\subsection{Related Work}\label{subsec:related-work}

\subsection{Overview}\label{subsec:overview}
Give an overview of the sections to follow


We use this database-program description together with Linear Temporal Logic (LTL) for describing temporal properties that is interesting with respect to the evolution of the database over time