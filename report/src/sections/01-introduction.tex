\section{Introduction}\label{sec:introduction}
Software analysis is a broad field encompassing a wide range of techniques and methodologies, each tailored to address specific aspects of software systems.
One such technique is value analysis, which focuses on the behavior of a program with respect to its input and output values~\cite{jackson_software_2000}.
Value analysis can be approached from various angles, including the consideration of meta-information like information flow or taint analysis.
While these approaches offer valuable insights into the behavior of a program, they often require detailed knowledge of the program's internal workings and are not always applicable to all types of software systems.
In this paper we use static program analysis, specifically abstract interpretation.

Abstract interpretation, first proposed by Cousot and Cousot in 1977~\cite{cousot_abstract_1977}, has emerged as a fundamental method for static program analysis.
Over the years, it has evolved into a versatile tool, finding applications across various programming paradigms and system architectures.
Its utility extends beyond traditional imperative programming to encompass object-oriented designs and concurrent systems~\cite{gustafsson_analyzing_2013, mine_static_2023}.
Abstract interpretation has played a pivotal role in analyzing a spectrum of program properties, from basic safety and liveness concerns to intricate security considerations~\cite{mastroeni_abstract_2011}.

Building upon this, Halder and Cortesi have expanded the application of abstract interpretation to domains like query languages~\cite{halder_abstract_2012}.
This paper continues in these footsteps, aiming to further explore and extend the capabilities of abstract interpretation within the context of query languages.


\subsection{Non-terminating Analysis}\label{subsec:non-terminating-analysis}
One problem with Halder and Cortesi is that the analysis they propose may not terminate.
To illustrate, consider the database schema \autoref{lst:motivate-sql} with the program in \autoref{lst:motivate-program}


\begin{listing}
    \begin{minted}{sql}
        CREATE TABLE account (
            name    TEXT,
            balance INT
        );
    \end{minted}
    \caption{A simple schema representing an account.}
    \label{lst:motivate-sql}
\end{listing}


\begin{listing}
    \begin{minted}{bash}
        while true do
            insert((name, balance), ("name", 1))
    \end{minted}
    \caption{A tiny program with nonterminating analysis.}
    \label{lst:motivate-program}
\end{listing}


Because the database context would continually change under Cortesi and Halder, the analysis would not terminate.
However, this doesn't have to be the case.
Extending the analysis to consider abstract tuples, not just abstract values, it is possible to have the analysis terminate for the program in \autoref{lst:motivate-program}.

\textbf{TODO:Show the contributions through a second example that runs through how we used the updated semantics. Move from method}


\subsection{Contributions}\label{subsec:contributions}
\todo[inline]{Casper says: These section (\ref{subsec:contributions}, \ref{subsec:related-work}, \ref{subsec:article-overview}) read like notes, I assume they are.}

Use Halder concretely for abstract interpretation

This paper builds on work of abstract interpretation of database queries by Cortesi and Halder.
Concretely, we use their work for analysing a database schema in relation to a program using the syntax they describe.


Improve on the levels of abstraction, i.e., add not just abstract values but also abstract tuples

Describe an implementable algorithm for performing static analysis targeting specific properties, given a program and database.

Prove soundness for the analysis.

Describe the properties we wish to check using LTL-like encodings, i.e., phrases like \emph{always, eventually,} and \emph{never}, to describe undesirable database states.
Additionally, we use LTL as described in X, Y, and Z to describe properties to check against.


\subsection{Related Work}\label{subsec:related-work}
Jana et al.~\cite{jana_extending_2020} have extended the application of abstract interpretation to the domain of web security.
Dependency information (data- and/or control-dependencies) among program variables and program statements is playing crucial roles in a wide range of software-engineering activities, e.g., program slicing, information flow security analysis, debugging, code optimization, code reuse, code understanding.
Most existing dependency analyzers focus on mainstream languages, and they do not support database applications embedding queries and data-manipulation commands.
This paper extends the Abstract Interpretation framework for static dependency analysis of database applications, providing a semantics-based computation tunable with respect to precision.

Kashyap et al.~\cite{kashyap_integrity_2022} have proposed a new approach to integrity checking of database applications using abstract interpretation.
The approach is based on the use of abstract interpretation to analyze the database application and to check the integrity of the data, i.e., to verify that the data is consistent with the constraints defined in the database management system.

We use this database-program description together with Linear Temporal Logic (LTL) for describing temporal properties that is interesting with respect to the evolution of the database over time.\todo{Casper says: same as above.}

\subsection{Article Overview}\label{subsec:article-overview}
\todo[inline]{Casper says: I think we could be more specific by calling the theory section \emph{Analysis Specification}.}
Give an overview of the sections to follow


The Theory section of this paper will cover the theoretical framework for analyzing an abstract interpretation of a database and application.
This includes the following:

\begin{itemize}
    \item The Abstract Domains, where the different domains of our model, such as strings and integers, will be explained.
    \item The Abstract Syntax and Semantics, where the abstract syntax is described and the abstract semantics is explained.
    \item Abstraction and Concretization describe how the abstractions relate to their concrete counterparts.
    % \item Finally, the Model Overview will show the system model used in the paper.
\end{itemize}

Through this, we establish the theoretical framework for analyzing an abstract interpretation of a database and application.
